import {
  __commonJS
} from "./chunk-JVWSFFO4.js";

// node_modules/ol-grid/dist/ol-grid.umd.js
var require_ol_grid_umd = __commonJS({
  "node_modules/ol-grid/dist/ol-grid.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.olGrid = factory());
    })(exports, function() {
      "use strict";
      var BaseEvent = (
        /** @class */
        function() {
          function BaseEvent2(type) {
            this.propagationStopped;
            this.defaultPrevented;
            this.type = type;
            this.target = null;
          }
          BaseEvent2.prototype.preventDefault = function() {
            this.defaultPrevented = true;
          };
          BaseEvent2.prototype.stopPropagation = function() {
            this.propagationStopped = true;
          };
          return BaseEvent2;
        }()
      );
      var Event = BaseEvent;
      var ObjectEventType = {
        /**
         * Triggered when a property is changed.
         * @event module:ol/Object.ObjectEvent#propertychange
         * @api
         */
        PROPERTYCHANGE: "propertychange"
      };
      var Disposable = (
        /** @class */
        function() {
          function Disposable2() {
            this.disposed = false;
          }
          Disposable2.prototype.dispose = function() {
            if (!this.disposed) {
              this.disposed = true;
              this.disposeInternal();
            }
          };
          Disposable2.prototype.disposeInternal = function() {
          };
          return Disposable2;
        }()
      );
      var Disposable$1 = Disposable;
      function numberSafeCompareFunction(a, b) {
        return a > b ? 1 : a < b ? -1 : 0;
      }
      function reverseSubArray(arr, begin, end) {
        while (begin < end) {
          var tmp = arr[begin];
          arr[begin] = arr[end];
          arr[end] = tmp;
          ++begin;
          --end;
        }
      }
      function extend$1(arr, data) {
        var extension = Array.isArray(data) ? data : [data];
        var length = extension.length;
        for (var i = 0; i < length; i++) {
          arr[arr.length] = extension[i];
        }
      }
      function equals$1(arr1, arr2) {
        var len1 = arr1.length;
        if (len1 !== arr2.length) {
          return false;
        }
        for (var i = 0; i < len1; i++) {
          if (arr1[i] !== arr2[i]) {
            return false;
          }
        }
        return true;
      }
      function TRUE() {
        return true;
      }
      function VOID() {
      }
      function memoizeOne(fn) {
        var called = false;
        var lastResult;
        var lastArgs;
        var lastThis;
        return function() {
          var nextArgs = Array.prototype.slice.call(arguments);
          if (!called || this !== lastThis || !equals$1(nextArgs, lastArgs)) {
            called = true;
            lastThis = this;
            lastArgs = nextArgs;
            lastResult = fn.apply(this, arguments);
          }
          return lastResult;
        };
      }
      var assign = typeof Object.assign === "function" ? Object.assign : function(target, var_sources) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        for (var i = 1, ii = arguments.length; i < ii; ++i) {
          var source = arguments[i];
          if (source !== void 0 && source !== null) {
            for (var key in source) {
              if (source.hasOwnProperty(key)) {
                output[key] = source[key];
              }
            }
          }
        }
        return output;
      };
      function clear(object) {
        for (var property in object) {
          delete object[property];
        }
      }
      var getValues = typeof Object.values === "function" ? Object.values : function(object) {
        var values = [];
        for (var property in object) {
          values.push(object[property]);
        }
        return values;
      };
      function isEmpty(object) {
        var property;
        for (property in object) {
          return false;
        }
        return !property;
      }
      var __extends$y = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Target = (
        /** @class */
        function(_super) {
          __extends$y(Target2, _super);
          function Target2(opt_target) {
            var _this = _super.call(this) || this;
            _this.eventTarget_ = opt_target;
            _this.pendingRemovals_ = null;
            _this.dispatching_ = null;
            _this.listeners_ = null;
            return _this;
          }
          Target2.prototype.addEventListener = function(type, listener) {
            if (!type || !listener) {
              return;
            }
            var listeners = this.listeners_ || (this.listeners_ = {});
            var listenersForType = listeners[type] || (listeners[type] = []);
            if (listenersForType.indexOf(listener) === -1) {
              listenersForType.push(listener);
            }
          };
          Target2.prototype.dispatchEvent = function(event) {
            var isString = typeof event === "string";
            var type = isString ? event : event.type;
            var listeners = this.listeners_ && this.listeners_[type];
            if (!listeners) {
              return;
            }
            var evt = isString ? new Event(event) : (
              /** @type {Event} */
              event
            );
            if (!evt.target) {
              evt.target = this.eventTarget_ || this;
            }
            var dispatching = this.dispatching_ || (this.dispatching_ = {});
            var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
            if (!(type in dispatching)) {
              dispatching[type] = 0;
              pendingRemovals[type] = 0;
            }
            ++dispatching[type];
            var propagate;
            for (var i = 0, ii = listeners.length; i < ii; ++i) {
              if ("handleEvent" in listeners[i]) {
                propagate = /** @type {import("../events.js").ListenerObject} */
                listeners[i].handleEvent(evt);
              } else {
                propagate = /** @type {import("../events.js").ListenerFunction} */
                listeners[i].call(this, evt);
              }
              if (propagate === false || evt.propagationStopped) {
                propagate = false;
                break;
              }
            }
            if (--dispatching[type] === 0) {
              var pr = pendingRemovals[type];
              delete pendingRemovals[type];
              while (pr--) {
                this.removeEventListener(type, VOID);
              }
              delete dispatching[type];
            }
            return propagate;
          };
          Target2.prototype.disposeInternal = function() {
            this.listeners_ && clear(this.listeners_);
          };
          Target2.prototype.getListeners = function(type) {
            return this.listeners_ && this.listeners_[type] || void 0;
          };
          Target2.prototype.hasListener = function(opt_type) {
            if (!this.listeners_) {
              return false;
            }
            return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
          };
          Target2.prototype.removeEventListener = function(type, listener) {
            var listeners = this.listeners_ && this.listeners_[type];
            if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                  listeners[index] = VOID;
                  ++this.pendingRemovals_[type];
                } else {
                  listeners.splice(index, 1);
                  if (listeners.length === 0) {
                    delete this.listeners_[type];
                  }
                }
              }
            }
          };
          return Target2;
        }(Disposable$1)
      );
      var EventTarget = Target;
      var EventType = {
        /**
         * Generic change event. Triggered when the revision counter is increased.
         * @event module:ol/events/Event~BaseEvent#change
         * @api
         */
        CHANGE: "change",
        /**
         * Generic error event. Triggered when an error occurs.
         * @event module:ol/events/Event~BaseEvent#error
         * @api
         */
        ERROR: "error",
        BLUR: "blur",
        CLEAR: "clear",
        CONTEXTMENU: "contextmenu",
        CLICK: "click",
        DBLCLICK: "dblclick",
        DRAGENTER: "dragenter",
        DRAGOVER: "dragover",
        DROP: "drop",
        FOCUS: "focus",
        KEYDOWN: "keydown",
        KEYPRESS: "keypress",
        LOAD: "load",
        RESIZE: "resize",
        TOUCHMOVE: "touchmove",
        WHEEL: "wheel"
      };
      function listen(target, type, listener, opt_this, opt_once) {
        if (opt_this && opt_this !== target) {
          listener = listener.bind(opt_this);
        }
        if (opt_once) {
          var originalListener_1 = listener;
          listener = function() {
            target.removeEventListener(type, listener);
            originalListener_1.apply(this, arguments);
          };
        }
        var eventsKey = {
          target,
          type,
          listener
        };
        target.addEventListener(type, listener);
        return eventsKey;
      }
      function listenOnce(target, type, listener, opt_this) {
        return listen(target, type, listener, opt_this, true);
      }
      function unlistenByKey(key) {
        if (key && key.target) {
          key.target.removeEventListener(key.type, key.listener);
          clear(key);
        }
      }
      var __extends$x = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Observable = (
        /** @class */
        function(_super) {
          __extends$x(Observable2, _super);
          function Observable2() {
            var _this = _super.call(this) || this;
            _this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
            _this.onInternal;
            _this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
            _this.onceInternal;
            _this.un = /** @type {ObservableOnSignature<void>} */
            _this.unInternal;
            _this.revision_ = 0;
            return _this;
          }
          Observable2.prototype.changed = function() {
            ++this.revision_;
            this.dispatchEvent(EventType.CHANGE);
          };
          Observable2.prototype.getRevision = function() {
            return this.revision_;
          };
          Observable2.prototype.onInternal = function(type, listener) {
            if (Array.isArray(type)) {
              var len = type.length;
              var keys = new Array(len);
              for (var i = 0; i < len; ++i) {
                keys[i] = listen(this, type[i], listener);
              }
              return keys;
            } else {
              return listen(
                this,
                /** @type {string} */
                type,
                listener
              );
            }
          };
          Observable2.prototype.onceInternal = function(type, listener) {
            var key;
            if (Array.isArray(type)) {
              var len = type.length;
              key = new Array(len);
              for (var i = 0; i < len; ++i) {
                key[i] = listenOnce(this, type[i], listener);
              }
            } else {
              key = listenOnce(
                this,
                /** @type {string} */
                type,
                listener
              );
            }
            listener.ol_key = key;
            return key;
          };
          Observable2.prototype.unInternal = function(type, listener) {
            var key = (
              /** @type {Object} */
              listener.ol_key
            );
            if (key) {
              unByKey(key);
            } else if (Array.isArray(type)) {
              for (var i = 0, ii = type.length; i < ii; ++i) {
                this.removeEventListener(type[i], listener);
              }
            } else {
              this.removeEventListener(type, listener);
            }
          };
          return Observable2;
        }(EventTarget)
      );
      Observable.prototype.on;
      Observable.prototype.once;
      Observable.prototype.un;
      function unByKey(key) {
        if (Array.isArray(key)) {
          for (var i = 0, ii = key.length; i < ii; ++i) {
            unlistenByKey(key[i]);
          }
        } else {
          unlistenByKey(
            /** @type {import("./events.js").EventsKey} */
            key
          );
        }
      }
      var Observable$1 = Observable;
      function abstract() {
        return (
          /** @type {?} */
          function() {
            throw new Error("Unimplemented abstract method.");
          }()
        );
      }
      var uidCounter_ = 0;
      function getUid(obj) {
        return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
      }
      var VERSION = "6.14.1";
      var __extends$w = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var ObjectEvent = (
        /** @class */
        function(_super) {
          __extends$w(ObjectEvent2, _super);
          function ObjectEvent2(type, key, oldValue) {
            var _this = _super.call(this, type) || this;
            _this.key = key;
            _this.oldValue = oldValue;
            return _this;
          }
          return ObjectEvent2;
        }(Event)
      );
      var BaseObject = (
        /** @class */
        function(_super) {
          __extends$w(BaseObject2, _super);
          function BaseObject2(opt_values) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            getUid(_this);
            _this.values_ = null;
            if (opt_values !== void 0) {
              _this.setProperties(opt_values);
            }
            return _this;
          }
          BaseObject2.prototype.get = function(key) {
            var value;
            if (this.values_ && this.values_.hasOwnProperty(key)) {
              value = this.values_[key];
            }
            return value;
          };
          BaseObject2.prototype.getKeys = function() {
            return this.values_ && Object.keys(this.values_) || [];
          };
          BaseObject2.prototype.getProperties = function() {
            return this.values_ && assign({}, this.values_) || {};
          };
          BaseObject2.prototype.hasProperties = function() {
            return !!this.values_;
          };
          BaseObject2.prototype.notify = function(key, oldValue) {
            var eventType;
            eventType = "change:".concat(key);
            if (this.hasListener(eventType)) {
              this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
            }
            eventType = ObjectEventType.PROPERTYCHANGE;
            if (this.hasListener(eventType)) {
              this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
            }
          };
          BaseObject2.prototype.addChangeListener = function(key, listener) {
            this.addEventListener("change:".concat(key), listener);
          };
          BaseObject2.prototype.removeChangeListener = function(key, listener) {
            this.removeEventListener("change:".concat(key), listener);
          };
          BaseObject2.prototype.set = function(key, value, opt_silent) {
            var values = this.values_ || (this.values_ = {});
            if (opt_silent) {
              values[key] = value;
            } else {
              var oldValue = values[key];
              values[key] = value;
              if (oldValue !== value) {
                this.notify(key, oldValue);
              }
            }
          };
          BaseObject2.prototype.setProperties = function(values, opt_silent) {
            for (var key in values) {
              this.set(key, values[key], opt_silent);
            }
          };
          BaseObject2.prototype.applyProperties = function(source) {
            if (!source.values_) {
              return;
            }
            assign(this.values_ || (this.values_ = {}), source.values_);
          };
          BaseObject2.prototype.unset = function(key, opt_silent) {
            if (this.values_ && key in this.values_) {
              var oldValue = this.values_[key];
              delete this.values_[key];
              if (isEmpty(this.values_)) {
                this.values_ = null;
              }
              if (!opt_silent) {
                this.notify(key, oldValue);
              }
            }
          };
          return BaseObject2;
        }(Observable$1)
      );
      var BaseObject$1 = BaseObject;
      var InteractionProperty = {
        ACTIVE: "active"
      };
      var __extends$v = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Interaction = (
        /** @class */
        function(_super) {
          __extends$v(Interaction2, _super);
          function Interaction2(opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            if (opt_options && opt_options.handleEvent) {
              _this.handleEvent = opt_options.handleEvent;
            }
            _this.map_ = null;
            _this.setActive(true);
            return _this;
          }
          Interaction2.prototype.getActive = function() {
            return (
              /** @type {boolean} */
              this.get(InteractionProperty.ACTIVE)
            );
          };
          Interaction2.prototype.getMap = function() {
            return this.map_;
          };
          Interaction2.prototype.handleEvent = function(mapBrowserEvent) {
            return true;
          };
          Interaction2.prototype.setActive = function(active) {
            this.set(InteractionProperty.ACTIVE, active);
          };
          Interaction2.prototype.setMap = function(map) {
            this.map_ = map;
          };
          return Interaction2;
        }(BaseObject$1)
      );
      var Interaction$1 = Interaction;
      var LayerProperty = {
        OPACITY: "opacity",
        VISIBLE: "visible",
        EXTENT: "extent",
        Z_INDEX: "zIndex",
        MAX_RESOLUTION: "maxResolution",
        MIN_RESOLUTION: "minResolution",
        MAX_ZOOM: "maxZoom",
        MIN_ZOOM: "minZoom",
        SOURCE: "source",
        MAP: "map"
      };
      var __extends$u = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var AssertionError = (
        /** @class */
        function(_super) {
          __extends$u(AssertionError2, _super);
          function AssertionError2(code) {
            var _this = this;
            var path = "v" + VERSION.split("-")[0];
            var message = "Assertion failed. See https://openlayers.org/en/" + path + "/doc/errors/#" + code + " for details.";
            _this = _super.call(this, message) || this;
            _this.code = code;
            _this.name = "AssertionError";
            _this.message = message;
            return _this;
          }
          return AssertionError2;
        }(Error)
      );
      var AssertionError$1 = AssertionError;
      function assert(assertion, errorCode) {
        if (!assertion) {
          throw new AssertionError$1(errorCode);
        }
      }
      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
      var cosh = function() {
        var cosh2;
        if ("cosh" in Math) {
          cosh2 = Math.cosh;
        } else {
          cosh2 = function(x) {
            var y = (
              /** @type {Math} */
              Math.exp(x)
            );
            return (y + 1 / y) / 2;
          };
        }
        return cosh2;
      }();
      function squaredDistance(x1, y1, x2, y2) {
        var dx = x2 - x1;
        var dy = y2 - y1;
        return dx * dx + dy * dy;
      }
      function toRadians(angleInDegrees) {
        return angleInDegrees * Math.PI / 180;
      }
      function lerp(a, b, x) {
        return a + x * (b - a);
      }
      var __extends$t = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var BaseLayer = (
        /** @class */
        function(_super) {
          __extends$t(BaseLayer2, _super);
          function BaseLayer2(options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.background_ = options.background;
            var properties = assign({}, options);
            if (typeof options.properties === "object") {
              delete properties.properties;
              assign(properties, options.properties);
            }
            properties[LayerProperty.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
            assert(typeof properties[LayerProperty.OPACITY] === "number", 64);
            properties[LayerProperty.VISIBLE] = options.visible !== void 0 ? options.visible : true;
            properties[LayerProperty.Z_INDEX] = options.zIndex;
            properties[LayerProperty.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
            properties[LayerProperty.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
            properties[LayerProperty.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
            properties[LayerProperty.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
            _this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
            delete properties.className;
            _this.setProperties(properties);
            _this.state_ = null;
            return _this;
          }
          BaseLayer2.prototype.getBackground = function() {
            return this.background_;
          };
          BaseLayer2.prototype.getClassName = function() {
            return this.className_;
          };
          BaseLayer2.prototype.getLayerState = function(opt_managed) {
            var state = this.state_ || /** @type {?} */
            {
              layer: this,
              managed: opt_managed === void 0 ? true : opt_managed
            };
            var zIndex = this.getZIndex();
            state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
            state.visible = this.getVisible();
            state.extent = this.getExtent();
            state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
            state.maxResolution = this.getMaxResolution();
            state.minResolution = Math.max(this.getMinResolution(), 0);
            state.minZoom = this.getMinZoom();
            state.maxZoom = this.getMaxZoom();
            this.state_ = state;
            return state;
          };
          BaseLayer2.prototype.getLayersArray = function(opt_array) {
            return abstract();
          };
          BaseLayer2.prototype.getLayerStatesArray = function(opt_states) {
            return abstract();
          };
          BaseLayer2.prototype.getExtent = function() {
            return (
              /** @type {import("../extent.js").Extent|undefined} */
              this.get(LayerProperty.EXTENT)
            );
          };
          BaseLayer2.prototype.getMaxResolution = function() {
            return (
              /** @type {number} */
              this.get(LayerProperty.MAX_RESOLUTION)
            );
          };
          BaseLayer2.prototype.getMinResolution = function() {
            return (
              /** @type {number} */
              this.get(LayerProperty.MIN_RESOLUTION)
            );
          };
          BaseLayer2.prototype.getMinZoom = function() {
            return (
              /** @type {number} */
              this.get(LayerProperty.MIN_ZOOM)
            );
          };
          BaseLayer2.prototype.getMaxZoom = function() {
            return (
              /** @type {number} */
              this.get(LayerProperty.MAX_ZOOM)
            );
          };
          BaseLayer2.prototype.getOpacity = function() {
            return (
              /** @type {number} */
              this.get(LayerProperty.OPACITY)
            );
          };
          BaseLayer2.prototype.getSourceState = function() {
            return abstract();
          };
          BaseLayer2.prototype.getVisible = function() {
            return (
              /** @type {boolean} */
              this.get(LayerProperty.VISIBLE)
            );
          };
          BaseLayer2.prototype.getZIndex = function() {
            return (
              /** @type {number} */
              this.get(LayerProperty.Z_INDEX)
            );
          };
          BaseLayer2.prototype.setBackground = function(opt_background) {
            this.background_ = opt_background;
            this.changed();
          };
          BaseLayer2.prototype.setExtent = function(extent) {
            this.set(LayerProperty.EXTENT, extent);
          };
          BaseLayer2.prototype.setMaxResolution = function(maxResolution) {
            this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
          };
          BaseLayer2.prototype.setMinResolution = function(minResolution) {
            this.set(LayerProperty.MIN_RESOLUTION, minResolution);
          };
          BaseLayer2.prototype.setMaxZoom = function(maxZoom) {
            this.set(LayerProperty.MAX_ZOOM, maxZoom);
          };
          BaseLayer2.prototype.setMinZoom = function(minZoom) {
            this.set(LayerProperty.MIN_ZOOM, minZoom);
          };
          BaseLayer2.prototype.setOpacity = function(opacity) {
            assert(typeof opacity === "number", 64);
            this.set(LayerProperty.OPACITY, opacity);
          };
          BaseLayer2.prototype.setVisible = function(visible) {
            this.set(LayerProperty.VISIBLE, visible);
          };
          BaseLayer2.prototype.setZIndex = function(zindex) {
            this.set(LayerProperty.Z_INDEX, zindex);
          };
          BaseLayer2.prototype.disposeInternal = function() {
            if (this.state_) {
              this.state_.layer = null;
              this.state_ = null;
            }
            _super.prototype.disposeInternal.call(this);
          };
          return BaseLayer2;
        }(BaseObject$1)
      );
      var BaseLayer$1 = BaseLayer;
      var RenderEventType = {
        /**
         * Triggered before a layer is rendered.
         * @event module:ol/render/Event~RenderEvent#prerender
         * @api
         */
        PRERENDER: "prerender",
        /**
         * Triggered after a layer is rendered.
         * @event module:ol/render/Event~RenderEvent#postrender
         * @api
         */
        POSTRENDER: "postrender",
        /**
         * Triggered before layers are composed.  When dispatched by the map, the event object will not have
         * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
         * WebGL layers currently dispatch this event.
         * @event module:ol/render/Event~RenderEvent#precompose
         * @api
         */
        PRECOMPOSE: "precompose",
        /**
         * Triggered after layers are composed.  When dispatched by the map, the event object will not have
         * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
         * WebGL layers currently dispatch this event.
         * @event module:ol/render/Event~RenderEvent#postcompose
         * @api
         */
        POSTCOMPOSE: "postcompose",
        /**
         * Triggered when rendering is complete, i.e. all sources and tiles have
         * finished loading for the current viewport, and all tiles are faded in.
         * The event object will not have a `context` set.
         * @event module:ol/render/Event~RenderEvent#rendercomplete
         * @api
         */
        RENDERCOMPLETE: "rendercomplete"
      };
      var SourceState = {
        UNDEFINED: "undefined",
        LOADING: "loading",
        READY: "ready",
        ERROR: "error"
      };
      var __extends$s = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Layer = (
        /** @class */
        function(_super) {
          __extends$s(Layer2, _super);
          function Layer2(options) {
            var _this = this;
            var baseOptions = assign({}, options);
            delete baseOptions.source;
            _this = _super.call(this, baseOptions) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.mapPrecomposeKey_ = null;
            _this.mapRenderKey_ = null;
            _this.sourceChangeKey_ = null;
            _this.renderer_ = null;
            _this.rendered = false;
            if (options.render) {
              _this.render = options.render;
            }
            if (options.map) {
              _this.setMap(options.map);
            }
            _this.addChangeListener(LayerProperty.SOURCE, _this.handleSourcePropertyChange_);
            var source = options.source ? (
              /** @type {SourceType} */
              options.source
            ) : null;
            _this.setSource(source);
            return _this;
          }
          Layer2.prototype.getLayersArray = function(opt_array) {
            var array = opt_array ? opt_array : [];
            array.push(this);
            return array;
          };
          Layer2.prototype.getLayerStatesArray = function(opt_states) {
            var states = opt_states ? opt_states : [];
            states.push(this.getLayerState());
            return states;
          };
          Layer2.prototype.getSource = function() {
            return (
              /** @type {SourceType} */
              this.get(LayerProperty.SOURCE) || null
            );
          };
          Layer2.prototype.getRenderSource = function() {
            return this.getSource();
          };
          Layer2.prototype.getSourceState = function() {
            var source = this.getSource();
            return !source ? SourceState.UNDEFINED : source.getState();
          };
          Layer2.prototype.handleSourceChange_ = function() {
            this.changed();
          };
          Layer2.prototype.handleSourcePropertyChange_ = function() {
            if (this.sourceChangeKey_) {
              unlistenByKey(this.sourceChangeKey_);
              this.sourceChangeKey_ = null;
            }
            var source = this.getSource();
            if (source) {
              this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
            }
            this.changed();
          };
          Layer2.prototype.getFeatures = function(pixel) {
            if (!this.renderer_) {
              return new Promise(function(resolve) {
                return resolve([]);
              });
            }
            return this.renderer_.getFeatures(pixel);
          };
          Layer2.prototype.getData = function(pixel) {
            if (!this.renderer_ || !this.rendered) {
              return null;
            }
            return this.renderer_.getData(pixel);
          };
          Layer2.prototype.render = function(frameState, target) {
            var layerRenderer = this.getRenderer();
            if (layerRenderer.prepareFrame(frameState)) {
              this.rendered = true;
              return layerRenderer.renderFrame(frameState, target);
            }
          };
          Layer2.prototype.unrender = function() {
            this.rendered = false;
          };
          Layer2.prototype.setMapInternal = function(map) {
            if (!map) {
              this.unrender();
            }
            this.set(LayerProperty.MAP, map);
          };
          Layer2.prototype.getMapInternal = function() {
            return this.get(LayerProperty.MAP);
          };
          Layer2.prototype.setMap = function(map) {
            if (this.mapPrecomposeKey_) {
              unlistenByKey(this.mapPrecomposeKey_);
              this.mapPrecomposeKey_ = null;
            }
            if (!map) {
              this.changed();
            }
            if (this.mapRenderKey_) {
              unlistenByKey(this.mapRenderKey_);
              this.mapRenderKey_ = null;
            }
            if (map) {
              this.mapPrecomposeKey_ = listen(map, RenderEventType.PRECOMPOSE, function(evt) {
                var renderEvent = (
                  /** @type {import("../render/Event.js").default} */
                  evt
                );
                var layerStatesArray = renderEvent.frameState.layerStatesArray;
                var layerState = this.getLayerState(false);
                assert(!layerStatesArray.some(function(arrayLayerState) {
                  return arrayLayerState.layer === layerState.layer;
                }), 67);
                layerStatesArray.push(layerState);
              }, this);
              this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
              this.changed();
            }
          };
          Layer2.prototype.setSource = function(source) {
            this.set(LayerProperty.SOURCE, source);
          };
          Layer2.prototype.getRenderer = function() {
            if (!this.renderer_) {
              this.renderer_ = this.createRenderer();
            }
            return this.renderer_;
          };
          Layer2.prototype.hasRenderer = function() {
            return !!this.renderer_;
          };
          Layer2.prototype.createRenderer = function() {
            return null;
          };
          Layer2.prototype.disposeInternal = function() {
            if (this.renderer_) {
              this.renderer_.dispose();
              delete this.renderer_;
            }
            this.setSource(null);
            _super.prototype.disposeInternal.call(this);
          };
          return Layer2;
        }(BaseLayer$1)
      );
      var Layer$1 = Layer;
      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }
      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);
          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
          }
          if (compare(arr[left], t) === 0) swap(arr, left, j);
          else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
        }
      }
      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      class RBush$2 {
        constructor(maxEntries = 9) {
          this._maxEntries = Math.max(4, maxEntries);
          this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
          this.clear();
        }
        all() {
          return this._all(this.data, []);
        }
        search(bbox) {
          let node = this.data;
          const result = [];
          if (!intersects$1(bbox, node)) return result;
          const toBBox = this.toBBox;
          const nodesToSearch = [];
          while (node) {
            for (let i = 0; i < node.children.length; i++) {
              const child = node.children[i];
              const childBBox = node.leaf ? toBBox(child) : child;
              if (intersects$1(bbox, childBBox)) {
                if (node.leaf) result.push(child);
                else if (contains(bbox, childBBox)) this._all(child, result);
                else nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        }
        collides(bbox) {
          let node = this.data;
          if (!intersects$1(bbox, node)) return false;
          const nodesToSearch = [];
          while (node) {
            for (let i = 0; i < node.children.length; i++) {
              const child = node.children[i];
              const childBBox = node.leaf ? this.toBBox(child) : child;
              if (intersects$1(bbox, childBBox)) {
                if (node.leaf || contains(bbox, childBBox)) return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        }
        load(data) {
          if (!(data && data.length)) return this;
          if (data.length < this._minEntries) {
            for (let i = 0; i < data.length; i++) {
              this.insert(data[i]);
            }
            return this;
          }
          let node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              const tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        }
        insert(item) {
          if (item) this._insert(item, this.data.height - 1);
          return this;
        }
        clear() {
          this.data = createNode([]);
          return this;
        }
        remove(item, equalsFn) {
          if (!item) return this;
          let node = this.data;
          const bbox = this.toBBox(item);
          const path = [];
          const indexes = [];
          let i, parent, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              const index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox)) {
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i++;
              node = parent.children[i];
              goingUp = false;
            } else node = null;
          }
          return this;
        }
        toBBox(item) {
          return item;
        }
        compareMinX(a, b) {
          return a.minX - b.minX;
        }
        compareMinY(a, b) {
          return a.minY - b.minY;
        }
        toJSON() {
          return this.data;
        }
        fromJSON(data) {
          this.data = data;
          return this;
        }
        _all(node, result) {
          const nodesToSearch = [];
          while (node) {
            if (node.leaf) result.push(...node.children);
            else nodesToSearch.push(...node.children);
            node = nodesToSearch.pop();
          }
          return result;
        }
        _build(items, left, right, height) {
          const N = right - left + 1;
          let M = this._maxEntries;
          let node;
          if (N <= M) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N) / Math.log(M));
            M = Math.ceil(N / Math.pow(M, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          const N2 = Math.ceil(N / M);
          const N1 = N2 * Math.ceil(Math.sqrt(M));
          multiSelect(items, left, right, N1, this.compareMinX);
          for (let i = left; i <= right; i += N1) {
            const right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (let j = i; j <= right2; j += N2) {
              const right3 = Math.min(j + N2 - 1, right2);
              node.children.push(this._build(items, j, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        }
        _chooseSubtree(bbox, node, level, path) {
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level) break;
            let minArea = Infinity;
            let minEnlargement = Infinity;
            let targetNode;
            for (let i = 0; i < node.children.length; i++) {
              const child = node.children[i];
              const area = bboxArea(child);
              const enlargement = enlargedArea(bbox, child) - area;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area < minArea ? area : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area < minArea) {
                  minArea = area;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        }
        _insert(item, level, isNode) {
          const bbox = isNode ? item : this.toBBox(item);
          const insertPath = [];
          const node = this._chooseSubtree(bbox, this.data, level, insertPath);
          node.children.push(item);
          extend(node, bbox);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else break;
          }
          this._adjustParentBBoxes(bbox, insertPath, level);
        }
        // split overflowed node into two
        _split(insertPath, level) {
          const node = insertPath[level];
          const M = node.children.length;
          const m = this._minEntries;
          this._chooseSplitAxis(node, m, M);
          const splitIndex = this._chooseSplitIndex(node, m, M);
          const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level) insertPath[level - 1].children.push(newNode);
          else this._splitRoot(node, newNode);
        }
        _splitRoot(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        }
        _chooseSplitIndex(node, m, M) {
          let index;
          let minOverlap = Infinity;
          let minArea = Infinity;
          for (let i = m; i <= M - m; i++) {
            const bbox1 = distBBox(node, 0, i, this.toBBox);
            const bbox2 = distBBox(node, i, M, this.toBBox);
            const overlap = intersectionArea(bbox1, bbox2);
            const area = bboxArea(bbox1) + bboxArea(bbox2);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;
              minArea = area < minArea ? area : minArea;
            } else if (overlap === minOverlap) {
              if (area < minArea) {
                minArea = area;
                index = i;
              }
            }
          }
          return index || M - m;
        }
        // sorts node children by the best axis for split
        _chooseSplitAxis(node, m, M) {
          const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
          const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
          const xMargin = this._allDistMargin(node, m, M, compareMinX);
          const yMargin = this._allDistMargin(node, m, M, compareMinY);
          if (xMargin < yMargin) node.children.sort(compareMinX);
        }
        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin(node, m, M, compare) {
          node.children.sort(compare);
          const toBBox = this.toBBox;
          const leftBBox = distBBox(node, 0, m, toBBox);
          const rightBBox = distBBox(node, M - m, M, toBBox);
          let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
          for (let i = m; i < M - m; i++) {
            const child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (let i = M - m - 1; i >= m; i--) {
            const child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        }
        _adjustParentBBoxes(bbox, path, level) {
          for (let i = level; i >= 0; i--) {
            extend(path[i], bbox);
          }
        }
        _condense(path) {
          for (let i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
              if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
              } else this.clear();
            } else calcBBox(path[i], this.toBBox);
          }
        }
      }
      function findItem(item, items, equalsFn) {
        if (!equalsFn) return items.indexOf(item);
        for (let i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) return i;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode) destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (let i = k; i < p; i++) {
          const child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        const minX = Math.max(a.minX, b.minX);
        const minY = Math.max(a.minY, b.minY);
        const maxX = Math.min(a.maxX, b.maxX);
        const maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects$1(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        const stack = [left, right];
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n) continue;
          const mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
      var ImageState = {
        IDLE: 0,
        LOADING: 1,
        LOADED: 2,
        ERROR: 3,
        EMPTY: 4
      };
      function toSize(size, opt_size) {
        if (Array.isArray(size)) {
          return size;
        } else {
          if (opt_size === void 0) {
            opt_size = [size, size];
          } else {
            opt_size[0] = size;
            opt_size[1] = size;
          }
          return opt_size;
        }
      }
      var ImageStyle = (
        /** @class */
        function() {
          function ImageStyle2(options) {
            this.opacity_ = options.opacity;
            this.rotateWithView_ = options.rotateWithView;
            this.rotation_ = options.rotation;
            this.scale_ = options.scale;
            this.scaleArray_ = toSize(options.scale);
            this.displacement_ = options.displacement;
          }
          ImageStyle2.prototype.clone = function() {
            var scale2 = this.getScale();
            return new ImageStyle2({
              opacity: this.getOpacity(),
              scale: Array.isArray(scale2) ? scale2.slice() : scale2,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice()
            });
          };
          ImageStyle2.prototype.getOpacity = function() {
            return this.opacity_;
          };
          ImageStyle2.prototype.getRotateWithView = function() {
            return this.rotateWithView_;
          };
          ImageStyle2.prototype.getRotation = function() {
            return this.rotation_;
          };
          ImageStyle2.prototype.getScale = function() {
            return this.scale_;
          };
          ImageStyle2.prototype.getScaleArray = function() {
            return this.scaleArray_;
          };
          ImageStyle2.prototype.getDisplacement = function() {
            return this.displacement_;
          };
          ImageStyle2.prototype.getAnchor = function() {
            return abstract();
          };
          ImageStyle2.prototype.getImage = function(pixelRatio) {
            return abstract();
          };
          ImageStyle2.prototype.getHitDetectionImage = function() {
            return abstract();
          };
          ImageStyle2.prototype.getPixelRatio = function(pixelRatio) {
            return 1;
          };
          ImageStyle2.prototype.getImageState = function() {
            return abstract();
          };
          ImageStyle2.prototype.getImageSize = function() {
            return abstract();
          };
          ImageStyle2.prototype.getOrigin = function() {
            return abstract();
          };
          ImageStyle2.prototype.getSize = function() {
            return abstract();
          };
          ImageStyle2.prototype.setDisplacement = function(displacement) {
            this.displacement_ = displacement;
          };
          ImageStyle2.prototype.setOpacity = function(opacity) {
            this.opacity_ = opacity;
          };
          ImageStyle2.prototype.setRotateWithView = function(rotateWithView) {
            this.rotateWithView_ = rotateWithView;
          };
          ImageStyle2.prototype.setRotation = function(rotation) {
            this.rotation_ = rotation;
          };
          ImageStyle2.prototype.setScale = function(scale2) {
            this.scale_ = scale2;
            this.scaleArray_ = toSize(scale2);
          };
          ImageStyle2.prototype.listenImageChange = function(listener) {
            abstract();
          };
          ImageStyle2.prototype.load = function() {
            abstract();
          };
          ImageStyle2.prototype.unlistenImageChange = function(listener) {
            abstract();
          };
          return ImageStyle2;
        }()
      );
      var ImageStyle$1 = ImageStyle;
      var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
      var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
      function asString(color) {
        if (typeof color === "string") {
          return color;
        } else {
          return toString$1(color);
        }
      }
      function fromNamed(color) {
        var el = document.createElement("div");
        el.style.color = color;
        if (el.style.color !== "") {
          document.body.appendChild(el);
          var rgb = getComputedStyle(el).color;
          document.body.removeChild(el);
          return rgb;
        } else {
          return "";
        }
      }
      var fromString = /* @__PURE__ */ function() {
        var MAX_CACHE_SIZE = 1024;
        var cache2 = {};
        var cacheSize = 0;
        return (
          /**
           * @param {string} s String.
           * @return {Color} Color.
           */
          function(s) {
            var color;
            if (cache2.hasOwnProperty(s)) {
              color = cache2[s];
            } else {
              if (cacheSize >= MAX_CACHE_SIZE) {
                var i = 0;
                for (var key in cache2) {
                  if ((i++ & 3) === 0) {
                    delete cache2[key];
                    --cacheSize;
                  }
                }
              }
              color = fromStringInternal_(s);
              cache2[s] = color;
              ++cacheSize;
            }
            return color;
          }
        );
      }();
      function asArray(color) {
        if (Array.isArray(color)) {
          return color;
        } else {
          return fromString(color);
        }
      }
      function fromStringInternal_(s) {
        var r, g, b, a, color;
        if (NAMED_COLOR_RE_.exec(s)) {
          s = fromNamed(s);
        }
        if (HEX_COLOR_RE_.exec(s)) {
          var n = s.length - 1;
          var d = (
            // number of digits per channel
            void 0
          );
          if (n <= 4) {
            d = 1;
          } else {
            d = 2;
          }
          var hasAlpha = n === 4 || n === 8;
          r = parseInt(s.substr(1 + 0 * d, d), 16);
          g = parseInt(s.substr(1 + 1 * d, d), 16);
          b = parseInt(s.substr(1 + 2 * d, d), 16);
          if (hasAlpha) {
            a = parseInt(s.substr(1 + 3 * d, d), 16);
          } else {
            a = 255;
          }
          if (d == 1) {
            r = (r << 4) + r;
            g = (g << 4) + g;
            b = (b << 4) + b;
            if (hasAlpha) {
              a = (a << 4) + a;
            }
          }
          color = [r, g, b, a / 255];
        } else if (s.indexOf("rgba(") == 0) {
          color = s.slice(5, -1).split(",").map(Number);
          normalize(color);
        } else if (s.indexOf("rgb(") == 0) {
          color = s.slice(4, -1).split(",").map(Number);
          color.push(1);
          normalize(color);
        } else {
          assert(false, 14);
        }
        return color;
      }
      function normalize(color) {
        color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
        color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
        color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
        color[3] = clamp(color[3], 0, 1);
        return color;
      }
      function toString$1(color) {
        var r = color[0];
        if (r != (r | 0)) {
          r = r + 0.5 | 0;
        }
        var g = color[1];
        if (g != (g | 0)) {
          g = g + 0.5 | 0;
        }
        var b = color[2];
        if (b != (b | 0)) {
          b = b + 0.5 | 0;
        }
        var a = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
        return "rgba(" + r + "," + g + "," + b + "," + a + ")";
      }
      function asColorLike(color) {
        if (Array.isArray(color)) {
          return toString$1(color);
        } else {
          return color;
        }
      }
      var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
      ua.indexOf("firefox") !== -1;
      var SAFARI = ua.indexOf("safari") !== -1 && ua.indexOf("chrom") == -1;
      SAFARI && !!(ua.indexOf("version/15.4") >= 0 || ua.match(/cpu (os|iphone os) 15_4 like mac os x/));
      ua.indexOf("webkit") !== -1 && ua.indexOf("edge") == -1;
      ua.indexOf("macintosh") !== -1;
      var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
      var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
      (function() {
        var passive = false;
        try {
          var options = Object.defineProperty({}, "passive", {
            get: function() {
              passive = true;
            }
          });
          window.addEventListener("_", null, options);
          window.removeEventListener("_", null, options);
        } catch (error) {
        }
        return passive;
      })();
      function createCanvasContext2D(opt_width, opt_height, opt_canvasPool, opt_Context2DSettings) {
        var canvas;
        if (opt_canvasPool && opt_canvasPool.length) {
          canvas = opt_canvasPool.shift();
        } else if (WORKER_OFFSCREEN_CANVAS) {
          canvas = new OffscreenCanvas(opt_width || 300, opt_height || 300);
        } else {
          canvas = document.createElement("canvas");
        }
        if (opt_width) {
          canvas.width = opt_width;
        }
        if (opt_height) {
          canvas.height = opt_height;
        }
        return (
          /** @type {CanvasRenderingContext2D} */
          canvas.getContext("2d", opt_Context2DSettings)
        );
      }
      var fontRegEx = new RegExp([
        "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
        "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
        "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
        "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
        `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
      ].join(""), "i");
      var fontRegExMatchIndex = [
        "style",
        "variant",
        "weight",
        "size",
        "lineHeight",
        "family"
      ];
      var getFontParameters = function(fontSpec) {
        var match = fontSpec.match(fontRegEx);
        if (!match) {
          return null;
        }
        var style = (
          /** @type {FontParameters} */
          {
            lineHeight: "normal",
            size: "1.2em",
            style: "normal",
            weight: "normal",
            variant: "normal"
          }
        );
        for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
          var value = match[i + 1];
          if (value !== void 0) {
            style[fontRegExMatchIndex[i]] = value;
          }
        }
        style.families = style.family.split(/,\s?/);
        return style;
      };
      function cssOpacity(opacity) {
        return opacity === 1 ? "" : String(Math.round(opacity * 100) / 100);
      }
      var defaultFont = "10px sans-serif";
      var defaultFillStyle = "#000";
      var defaultLineCap = "round";
      var defaultLineDash = [];
      var defaultLineDashOffset = 0;
      var defaultLineJoin = "round";
      var defaultMiterLimit = 10;
      var defaultStrokeStyle = "#000";
      var defaultTextAlign = "center";
      var defaultTextBaseline = "middle";
      var defaultPadding = [0, 0, 0, 0];
      var defaultLineWidth = 1;
      var checkedFonts = new BaseObject$1();
      var labelCache = new EventTarget();
      labelCache.setSize = function() {
        console.warn("labelCache is deprecated.");
      };
      var measureContext = null;
      var measureFont;
      var textHeights = {};
      var registerFont = function() {
        var retries = 100;
        var size = "32px ";
        var referenceFonts = ["monospace", "serif"];
        var len = referenceFonts.length;
        var text = "wmytzilWMYTZIL@#/&?$%10";
        var interval, referenceWidth;
        function isAvailable(fontStyle, fontWeight, fontFamily) {
          var available = true;
          for (var i = 0; i < len; ++i) {
            var referenceFont = referenceFonts[i];
            referenceWidth = measureTextWidth(fontStyle + " " + fontWeight + " " + size + referenceFont, text);
            if (fontFamily != referenceFont) {
              var width = measureTextWidth(fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont, text);
              available = available && width != referenceWidth;
            }
          }
          if (available) {
            return true;
          }
          return false;
        }
        function check() {
          var done = true;
          var fonts = checkedFonts.getKeys();
          for (var i = 0, ii = fonts.length; i < ii; ++i) {
            var font = fonts[i];
            if (checkedFonts.get(font) < retries) {
              if (isAvailable.apply(this, font.split("\n"))) {
                clear(textHeights);
                measureContext = null;
                measureFont = void 0;
                checkedFonts.set(font, retries);
              } else {
                checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                done = false;
              }
            }
          }
          if (done) {
            clearInterval(interval);
            interval = void 0;
          }
        }
        return function(fontSpec) {
          var font = getFontParameters(fontSpec);
          if (!font) {
            return;
          }
          var families = font.families;
          for (var i = 0, ii = families.length; i < ii; ++i) {
            var family = families[i];
            var key = font.style + "\n" + font.weight + "\n" + family;
            if (checkedFonts.get(key) === void 0) {
              checkedFonts.set(key, retries, true);
              if (!isAvailable(font.style, font.weight, family)) {
                checkedFonts.set(key, 0, true);
                if (interval === void 0) {
                  interval = setInterval(check, 32);
                }
              }
            }
          }
        };
      }();
      var measureTextHeight = /* @__PURE__ */ function() {
        var measureElement;
        return function(fontSpec) {
          var height = textHeights[fontSpec];
          if (height == void 0) {
            if (WORKER_OFFSCREEN_CANVAS) {
              var font = getFontParameters(fontSpec);
              var metrics = measureText(fontSpec, "Žg");
              var lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
              height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
            } else {
              if (!measureElement) {
                measureElement = document.createElement("div");
                measureElement.innerHTML = "M";
                measureElement.style.minHeight = "0";
                measureElement.style.maxHeight = "none";
                measureElement.style.height = "auto";
                measureElement.style.padding = "0";
                measureElement.style.border = "none";
                measureElement.style.position = "absolute";
                measureElement.style.display = "block";
                measureElement.style.left = "-99999px";
              }
              measureElement.style.font = fontSpec;
              document.body.appendChild(measureElement);
              height = measureElement.offsetHeight;
              document.body.removeChild(measureElement);
            }
            textHeights[fontSpec] = height;
          }
          return height;
        };
      }();
      function measureText(font, text) {
        if (!measureContext) {
          measureContext = createCanvasContext2D(1, 1);
        }
        if (font != measureFont) {
          measureContext.font = font;
          measureFont = measureContext.font;
        }
        return measureContext.measureText(text);
      }
      function measureTextWidth(font, text) {
        return measureText(font, text).width;
      }
      function measureAndCacheTextWidth(font, text, cache2) {
        if (text in cache2) {
          return cache2[text];
        }
        var width = measureTextWidth(font, text);
        cache2[text] = width;
        return width;
      }
      function getTextDimensions(baseStyle, chunks) {
        var widths = [];
        var heights = [];
        var lineWidths = [];
        var width = 0;
        var lineWidth = 0;
        var height = 0;
        var lineHeight = 0;
        for (var i = 0, ii = chunks.length; i <= ii; i += 2) {
          var text = chunks[i];
          if (text === "\n" || i === ii) {
            width = Math.max(width, lineWidth);
            lineWidths.push(lineWidth);
            lineWidth = 0;
            height += lineHeight;
            continue;
          }
          var font = chunks[i + 1] || baseStyle.font;
          var currentWidth = measureTextWidth(font, text);
          widths.push(currentWidth);
          lineWidth += currentWidth;
          var currentHeight = measureTextHeight(font);
          heights.push(currentHeight);
          lineHeight = Math.max(lineHeight, currentHeight);
        }
        return { width, height, widths, heights, lineWidths };
      }
      function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale2) {
        context.save();
        if (opacity !== 1) {
          context.globalAlpha *= opacity;
        }
        if (transform2) {
          context.setTransform.apply(context, transform2);
        }
        if (
          /** @type {*} */
          labelOrImage.contextInstructions
        ) {
          context.translate(x, y);
          context.scale(scale2[0], scale2[1]);
          executeLabelInstructions(
            /** @type {Label} */
            labelOrImage,
            context
          );
        } else if (scale2[0] < 0 || scale2[1] < 0) {
          context.translate(x, y);
          context.scale(scale2[0], scale2[1]);
          context.drawImage(
            /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
            labelOrImage,
            originX,
            originY,
            w,
            h,
            0,
            0,
            w,
            h
          );
        } else {
          context.drawImage(
            /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
            labelOrImage,
            originX,
            originY,
            w,
            h,
            x,
            y,
            w * scale2[0],
            h * scale2[1]
          );
        }
        context.restore();
      }
      function executeLabelInstructions(label, context) {
        var contextInstructions = label.contextInstructions;
        for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
          if (Array.isArray(contextInstructions[i + 1])) {
            context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
          } else {
            context[contextInstructions[i]] = contextInstructions[i + 1];
          }
        }
      }
      var __extends$r = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var RegularShape = (
        /** @class */
        function(_super) {
          __extends$r(RegularShape2, _super);
          function RegularShape2(options) {
            var _this = this;
            var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
            _this = _super.call(this, {
              opacity: 1,
              rotateWithView,
              rotation: options.rotation !== void 0 ? options.rotation : 0,
              scale: options.scale !== void 0 ? options.scale : 1,
              displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
            }) || this;
            _this.canvas_ = void 0;
            _this.hitDetectionCanvas_ = null;
            _this.fill_ = options.fill !== void 0 ? options.fill : null;
            _this.origin_ = [0, 0];
            _this.points_ = options.points;
            _this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
            _this.radius2_ = options.radius2;
            _this.angle_ = options.angle !== void 0 ? options.angle : 0;
            _this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
            _this.size_ = null;
            _this.renderOptions_ = null;
            _this.render();
            return _this;
          }
          RegularShape2.prototype.clone = function() {
            var scale2 = this.getScale();
            var style = new RegularShape2({
              fill: this.getFill() ? this.getFill().clone() : void 0,
              points: this.getPoints(),
              radius: this.getRadius(),
              radius2: this.getRadius2(),
              angle: this.getAngle(),
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              scale: Array.isArray(scale2) ? scale2.slice() : scale2,
              displacement: this.getDisplacement().slice()
            });
            style.setOpacity(this.getOpacity());
            return style;
          };
          RegularShape2.prototype.getAnchor = function() {
            var size = this.size_;
            if (!size) {
              return null;
            }
            var displacement = this.getDisplacement();
            return [size[0] / 2 - displacement[0], size[1] / 2 + displacement[1]];
          };
          RegularShape2.prototype.getAngle = function() {
            return this.angle_;
          };
          RegularShape2.prototype.getFill = function() {
            return this.fill_;
          };
          RegularShape2.prototype.getHitDetectionImage = function() {
            if (!this.hitDetectionCanvas_) {
              this.createHitDetectionCanvas_(this.renderOptions_);
            }
            return this.hitDetectionCanvas_;
          };
          RegularShape2.prototype.getImage = function(pixelRatio) {
            var image = this.canvas_[pixelRatio];
            if (!image) {
              var renderOptions = this.renderOptions_;
              var context = createCanvasContext2D(renderOptions.size * pixelRatio, renderOptions.size * pixelRatio);
              this.draw_(renderOptions, context, pixelRatio);
              image = context.canvas;
              this.canvas_[pixelRatio] = image;
            }
            return image;
          };
          RegularShape2.prototype.getPixelRatio = function(pixelRatio) {
            return pixelRatio;
          };
          RegularShape2.prototype.getImageSize = function() {
            return this.size_;
          };
          RegularShape2.prototype.getImageState = function() {
            return ImageState.LOADED;
          };
          RegularShape2.prototype.getOrigin = function() {
            return this.origin_;
          };
          RegularShape2.prototype.getPoints = function() {
            return this.points_;
          };
          RegularShape2.prototype.getRadius = function() {
            return this.radius_;
          };
          RegularShape2.prototype.getRadius2 = function() {
            return this.radius2_;
          };
          RegularShape2.prototype.getSize = function() {
            return this.size_;
          };
          RegularShape2.prototype.getStroke = function() {
            return this.stroke_;
          };
          RegularShape2.prototype.listenImageChange = function(listener) {
          };
          RegularShape2.prototype.load = function() {
          };
          RegularShape2.prototype.unlistenImageChange = function(listener) {
          };
          RegularShape2.prototype.calculateLineJoinSize_ = function(lineJoin, strokeWidth, miterLimit) {
            if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
              return strokeWidth;
            }
            var r1 = this.radius_;
            var r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
            if (r1 < r2) {
              var tmp = r1;
              r1 = r2;
              r2 = tmp;
            }
            var points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
            var alpha = 2 * Math.PI / points;
            var a = r2 * Math.sin(alpha);
            var b = Math.sqrt(r2 * r2 - a * a);
            var d = r1 - b;
            var e = Math.sqrt(a * a + d * d);
            var miterRatio = e / a;
            if (lineJoin === "miter" && miterRatio <= miterLimit) {
              return miterRatio * strokeWidth;
            }
            var k = strokeWidth / 2 / miterRatio;
            var l = strokeWidth / 2 * (d / e);
            var maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
            var bevelAdd = maxr - r1;
            if (this.radius2_ === void 0 || lineJoin === "bevel") {
              return bevelAdd * 2;
            }
            var aa = r1 * Math.sin(alpha);
            var bb = Math.sqrt(r1 * r1 - aa * aa);
            var dd = r2 - bb;
            var ee = Math.sqrt(aa * aa + dd * dd);
            var innerMiterRatio = ee / aa;
            if (innerMiterRatio <= miterLimit) {
              var innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
              return 2 * Math.max(bevelAdd, innerLength);
            }
            return bevelAdd * 2;
          };
          RegularShape2.prototype.createRenderOptions = function() {
            var lineJoin = defaultLineJoin;
            var miterLimit = 0;
            var lineDash = null;
            var lineDashOffset = 0;
            var strokeStyle;
            var strokeWidth = 0;
            if (this.stroke_) {
              strokeStyle = this.stroke_.getColor();
              if (strokeStyle === null) {
                strokeStyle = defaultStrokeStyle;
              }
              strokeStyle = asColorLike(strokeStyle);
              strokeWidth = this.stroke_.getWidth();
              if (strokeWidth === void 0) {
                strokeWidth = defaultLineWidth;
              }
              lineDash = this.stroke_.getLineDash();
              lineDashOffset = this.stroke_.getLineDashOffset();
              lineJoin = this.stroke_.getLineJoin();
              if (lineJoin === void 0) {
                lineJoin = defaultLineJoin;
              }
              miterLimit = this.stroke_.getMiterLimit();
              if (miterLimit === void 0) {
                miterLimit = defaultMiterLimit;
              }
            }
            var add2 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
            var maxRadius = Math.max(this.radius_, this.radius2_ || 0);
            var size = Math.ceil(2 * maxRadius + add2);
            return {
              strokeStyle,
              strokeWidth,
              size,
              lineDash,
              lineDashOffset,
              lineJoin,
              miterLimit
            };
          };
          RegularShape2.prototype.render = function() {
            this.renderOptions_ = this.createRenderOptions();
            var size = this.renderOptions_.size;
            this.canvas_ = {};
            this.size_ = [size, size];
          };
          RegularShape2.prototype.draw_ = function(renderOptions, context, pixelRatio) {
            context.scale(pixelRatio, pixelRatio);
            context.translate(renderOptions.size / 2, renderOptions.size / 2);
            this.createPath_(context);
            if (this.fill_) {
              var color = this.fill_.getColor();
              if (color === null) {
                color = defaultFillStyle;
              }
              context.fillStyle = asColorLike(color);
              context.fill();
            }
            if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (context.setLineDash && renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.lineJoin = renderOptions.lineJoin;
              context.miterLimit = renderOptions.miterLimit;
              context.stroke();
            }
          };
          RegularShape2.prototype.createHitDetectionCanvas_ = function(renderOptions) {
            if (this.fill_) {
              var color = this.fill_.getColor();
              var opacity = 0;
              if (typeof color === "string") {
                color = asArray(color);
              }
              if (color === null) {
                opacity = 1;
              } else if (Array.isArray(color)) {
                opacity = color.length === 4 ? color[3] : 1;
              }
              if (opacity === 0) {
                var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
                this.hitDetectionCanvas_ = context.canvas;
                this.drawHitDetectionCanvas_(renderOptions, context);
              }
            }
            if (!this.hitDetectionCanvas_) {
              this.hitDetectionCanvas_ = this.getImage(1);
            }
          };
          RegularShape2.prototype.createPath_ = function(context) {
            var points = this.points_;
            var radius = this.radius_;
            if (points === Infinity) {
              context.arc(0, 0, radius, 0, 2 * Math.PI);
            } else {
              var radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
              if (this.radius2_ !== void 0) {
                points *= 2;
              }
              var startAngle = this.angle_ - Math.PI / 2;
              var step = 2 * Math.PI / points;
              for (var i = 0; i < points; i++) {
                var angle0 = startAngle + i * step;
                var radiusC = i % 2 === 0 ? radius : radius2;
                context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
              }
              context.closePath();
            }
          };
          RegularShape2.prototype.drawHitDetectionCanvas_ = function(renderOptions, context) {
            context.translate(renderOptions.size / 2, renderOptions.size / 2);
            this.createPath_(context);
            context.fillStyle = defaultFillStyle;
            context.fill();
            if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (renderOptions.lineDash) {
                context.setLineDash(renderOptions.lineDash);
                context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.lineJoin = renderOptions.lineJoin;
              context.miterLimit = renderOptions.miterLimit;
              context.stroke();
            }
          };
          return RegularShape2;
        }(ImageStyle$1)
      );
      var RegularShape$1 = RegularShape;
      var __extends$q = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var CircleStyle = (
        /** @class */
        function(_super) {
          __extends$q(CircleStyle2, _super);
          function CircleStyle2(opt_options) {
            var options = opt_options ? opt_options : {};
            return _super.call(this, {
              points: Infinity,
              fill: options.fill,
              radius: options.radius,
              stroke: options.stroke,
              scale: options.scale !== void 0 ? options.scale : 1,
              rotation: options.rotation !== void 0 ? options.rotation : 0,
              rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
              displacement: options.displacement !== void 0 ? options.displacement : [0, 0]
            }) || this;
          }
          CircleStyle2.prototype.clone = function() {
            var scale2 = this.getScale();
            var style = new CircleStyle2({
              fill: this.getFill() ? this.getFill().clone() : void 0,
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              radius: this.getRadius(),
              scale: Array.isArray(scale2) ? scale2.slice() : scale2,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice()
            });
            style.setOpacity(this.getOpacity());
            return style;
          };
          CircleStyle2.prototype.setRadius = function(radius) {
            this.radius_ = radius;
            this.render();
          };
          return CircleStyle2;
        }(RegularShape$1)
      );
      var CircleStyle$1 = CircleStyle;
      var Fill = (
        /** @class */
        function() {
          function Fill2(opt_options) {
            var options = opt_options || {};
            this.color_ = options.color !== void 0 ? options.color : null;
          }
          Fill2.prototype.clone = function() {
            var color = this.getColor();
            return new Fill2({
              color: Array.isArray(color) ? color.slice() : color || void 0
            });
          };
          Fill2.prototype.getColor = function() {
            return this.color_;
          };
          Fill2.prototype.setColor = function(color) {
            this.color_ = color;
          };
          return Fill2;
        }()
      );
      var Fill$1 = Fill;
      var GeometryType = {
        POINT: "Point",
        LINE_STRING: "LineString",
        LINEAR_RING: "LinearRing",
        POLYGON: "Polygon",
        MULTI_POINT: "MultiPoint",
        MULTI_LINE_STRING: "MultiLineString",
        MULTI_POLYGON: "MultiPolygon",
        GEOMETRY_COLLECTION: "GeometryCollection",
        CIRCLE: "Circle"
      };
      var Stroke = (
        /** @class */
        function() {
          function Stroke2(opt_options) {
            var options = opt_options || {};
            this.color_ = options.color !== void 0 ? options.color : null;
            this.lineCap_ = options.lineCap;
            this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
            this.lineDashOffset_ = options.lineDashOffset;
            this.lineJoin_ = options.lineJoin;
            this.miterLimit_ = options.miterLimit;
            this.width_ = options.width;
          }
          Stroke2.prototype.clone = function() {
            var color = this.getColor();
            return new Stroke2({
              color: Array.isArray(color) ? color.slice() : color || void 0,
              lineCap: this.getLineCap(),
              lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
              lineDashOffset: this.getLineDashOffset(),
              lineJoin: this.getLineJoin(),
              miterLimit: this.getMiterLimit(),
              width: this.getWidth()
            });
          };
          Stroke2.prototype.getColor = function() {
            return this.color_;
          };
          Stroke2.prototype.getLineCap = function() {
            return this.lineCap_;
          };
          Stroke2.prototype.getLineDash = function() {
            return this.lineDash_;
          };
          Stroke2.prototype.getLineDashOffset = function() {
            return this.lineDashOffset_;
          };
          Stroke2.prototype.getLineJoin = function() {
            return this.lineJoin_;
          };
          Stroke2.prototype.getMiterLimit = function() {
            return this.miterLimit_;
          };
          Stroke2.prototype.getWidth = function() {
            return this.width_;
          };
          Stroke2.prototype.setColor = function(color) {
            this.color_ = color;
          };
          Stroke2.prototype.setLineCap = function(lineCap) {
            this.lineCap_ = lineCap;
          };
          Stroke2.prototype.setLineDash = function(lineDash) {
            this.lineDash_ = lineDash;
          };
          Stroke2.prototype.setLineDashOffset = function(lineDashOffset) {
            this.lineDashOffset_ = lineDashOffset;
          };
          Stroke2.prototype.setLineJoin = function(lineJoin) {
            this.lineJoin_ = lineJoin;
          };
          Stroke2.prototype.setMiterLimit = function(miterLimit) {
            this.miterLimit_ = miterLimit;
          };
          Stroke2.prototype.setWidth = function(width) {
            this.width_ = width;
          };
          return Stroke2;
        }()
      );
      var Stroke$1 = Stroke;
      var Style = (
        /** @class */
        function() {
          function Style2(opt_options) {
            var options = opt_options || {};
            this.geometry_ = null;
            this.geometryFunction_ = defaultGeometryFunction;
            if (options.geometry !== void 0) {
              this.setGeometry(options.geometry);
            }
            this.fill_ = options.fill !== void 0 ? options.fill : null;
            this.image_ = options.image !== void 0 ? options.image : null;
            this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
            this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
            this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
            this.text_ = options.text !== void 0 ? options.text : null;
            this.zIndex_ = options.zIndex;
          }
          Style2.prototype.clone = function() {
            var geometry = this.getGeometry();
            if (geometry && typeof geometry === "object") {
              geometry = /** @type {import("../geom/Geometry.js").default} */
              geometry.clone();
            }
            return new Style2({
              geometry,
              fill: this.getFill() ? this.getFill().clone() : void 0,
              image: this.getImage() ? this.getImage().clone() : void 0,
              renderer: this.getRenderer(),
              stroke: this.getStroke() ? this.getStroke().clone() : void 0,
              text: this.getText() ? this.getText().clone() : void 0,
              zIndex: this.getZIndex()
            });
          };
          Style2.prototype.getRenderer = function() {
            return this.renderer_;
          };
          Style2.prototype.setRenderer = function(renderer) {
            this.renderer_ = renderer;
          };
          Style2.prototype.setHitDetectionRenderer = function(renderer) {
            this.hitDetectionRenderer_ = renderer;
          };
          Style2.prototype.getHitDetectionRenderer = function() {
            return this.hitDetectionRenderer_;
          };
          Style2.prototype.getGeometry = function() {
            return this.geometry_;
          };
          Style2.prototype.getGeometryFunction = function() {
            return this.geometryFunction_;
          };
          Style2.prototype.getFill = function() {
            return this.fill_;
          };
          Style2.prototype.setFill = function(fill) {
            this.fill_ = fill;
          };
          Style2.prototype.getImage = function() {
            return this.image_;
          };
          Style2.prototype.setImage = function(image) {
            this.image_ = image;
          };
          Style2.prototype.getStroke = function() {
            return this.stroke_;
          };
          Style2.prototype.setStroke = function(stroke) {
            this.stroke_ = stroke;
          };
          Style2.prototype.getText = function() {
            return this.text_;
          };
          Style2.prototype.setText = function(text) {
            this.text_ = text;
          };
          Style2.prototype.getZIndex = function() {
            return this.zIndex_;
          };
          Style2.prototype.setGeometry = function(geometry) {
            if (typeof geometry === "function") {
              this.geometryFunction_ = geometry;
            } else if (typeof geometry === "string") {
              this.geometryFunction_ = function(feature) {
                return (
                  /** @type {import("../geom/Geometry.js").default} */
                  feature.get(geometry)
                );
              };
            } else if (!geometry) {
              this.geometryFunction_ = defaultGeometryFunction;
            } else if (geometry !== void 0) {
              this.geometryFunction_ = function() {
                return (
                  /** @type {import("../geom/Geometry.js").default} */
                  geometry
                );
              };
            }
            this.geometry_ = geometry;
          };
          Style2.prototype.setZIndex = function(zIndex) {
            this.zIndex_ = zIndex;
          };
          return Style2;
        }()
      );
      function toFunction(obj) {
        var styleFunction;
        if (typeof obj === "function") {
          styleFunction = obj;
        } else {
          var styles_1;
          if (Array.isArray(obj)) {
            styles_1 = obj;
          } else {
            assert(typeof /** @type {?} */
            obj.getZIndex === "function", 41);
            var style = (
              /** @type {Style} */
              obj
            );
            styles_1 = [style];
          }
          styleFunction = function() {
            return styles_1;
          };
        }
        return styleFunction;
      }
      var defaultStyles = null;
      function createDefaultStyle(feature, resolution) {
        if (!defaultStyles) {
          var fill = new Fill$1({
            color: "rgba(255,255,255,0.4)"
          });
          var stroke = new Stroke$1({
            color: "#3399CC",
            width: 1.25
          });
          defaultStyles = [
            new Style({
              image: new CircleStyle$1({
                fill,
                stroke,
                radius: 5
              }),
              fill,
              stroke
            })
          ];
        }
        return defaultStyles;
      }
      function defaultGeometryFunction(feature) {
        return feature.getGeometry();
      }
      var __extends$p = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Property$1 = {
        RENDER_ORDER: "renderOrder"
      };
      var BaseVectorLayer = (
        /** @class */
        function(_super) {
          __extends$p(BaseVectorLayer2, _super);
          function BaseVectorLayer2(opt_options) {
            var _this = this;
            var options = opt_options ? opt_options : {};
            var baseOptions = assign({}, options);
            delete baseOptions.style;
            delete baseOptions.renderBuffer;
            delete baseOptions.updateWhileAnimating;
            delete baseOptions.updateWhileInteracting;
            _this = _super.call(this, baseOptions) || this;
            _this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
            _this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
            _this.style_ = null;
            _this.styleFunction_ = void 0;
            _this.setStyle(options.style);
            _this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
            _this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
            return _this;
          }
          BaseVectorLayer2.prototype.getDeclutter = function() {
            return this.declutter_;
          };
          BaseVectorLayer2.prototype.getFeatures = function(pixel) {
            return _super.prototype.getFeatures.call(this, pixel);
          };
          BaseVectorLayer2.prototype.getRenderBuffer = function() {
            return this.renderBuffer_;
          };
          BaseVectorLayer2.prototype.getRenderOrder = function() {
            return (
              /** @type {import("../render.js").OrderFunction|null|undefined} */
              this.get(Property$1.RENDER_ORDER)
            );
          };
          BaseVectorLayer2.prototype.getStyle = function() {
            return this.style_;
          };
          BaseVectorLayer2.prototype.getStyleFunction = function() {
            return this.styleFunction_;
          };
          BaseVectorLayer2.prototype.getUpdateWhileAnimating = function() {
            return this.updateWhileAnimating_;
          };
          BaseVectorLayer2.prototype.getUpdateWhileInteracting = function() {
            return this.updateWhileInteracting_;
          };
          BaseVectorLayer2.prototype.renderDeclutter = function(frameState) {
            if (!frameState.declutterTree) {
              frameState.declutterTree = new RBush$2(9);
            }
            this.getRenderer().renderDeclutter(frameState);
          };
          BaseVectorLayer2.prototype.setRenderOrder = function(renderOrder) {
            this.set(Property$1.RENDER_ORDER, renderOrder);
          };
          BaseVectorLayer2.prototype.setStyle = function(opt_style) {
            this.style_ = opt_style !== void 0 ? opt_style : createDefaultStyle;
            this.styleFunction_ = opt_style === null ? void 0 : toFunction(this.style_);
            this.changed();
          };
          return BaseVectorLayer2;
        }(Layer$1)
      );
      var BaseVectorLayer$1 = BaseVectorLayer;
      var Instruction = {
        BEGIN_GEOMETRY: 0,
        BEGIN_PATH: 1,
        CIRCLE: 2,
        CLOSE_PATH: 3,
        CUSTOM: 4,
        DRAW_CHARS: 5,
        DRAW_IMAGE: 6,
        END_GEOMETRY: 7,
        FILL: 8,
        MOVE_TO_LINE_TO: 9,
        SET_FILL_STYLE: 10,
        SET_STROKE_STYLE: 11,
        STROKE: 12
      };
      var fillInstruction = [Instruction.FILL];
      var strokeInstruction = [Instruction.STROKE];
      var beginPathInstruction = [Instruction.BEGIN_PATH];
      var closePathInstruction = [Instruction.CLOSE_PATH];
      var CanvasInstruction = Instruction;
      var Relationship = {
        UNKNOWN: 0,
        INTERSECTING: 1,
        ABOVE: 2,
        RIGHT: 4,
        BELOW: 8,
        LEFT: 16
      };
      var VectorContext = (
        /** @class */
        function() {
          function VectorContext2() {
          }
          VectorContext2.prototype.drawCustom = function(geometry, feature, renderer, hitDetectionRenderer) {
          };
          VectorContext2.prototype.drawGeometry = function(geometry) {
          };
          VectorContext2.prototype.setStyle = function(style) {
          };
          VectorContext2.prototype.drawCircle = function(circleGeometry, feature) {
          };
          VectorContext2.prototype.drawFeature = function(feature, style) {
          };
          VectorContext2.prototype.drawGeometryCollection = function(geometryCollectionGeometry, feature) {
          };
          VectorContext2.prototype.drawLineString = function(lineStringGeometry, feature) {
          };
          VectorContext2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
          };
          VectorContext2.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
          };
          VectorContext2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
          };
          VectorContext2.prototype.drawPoint = function(pointGeometry, feature) {
          };
          VectorContext2.prototype.drawPolygon = function(polygonGeometry, feature) {
          };
          VectorContext2.prototype.drawText = function(geometry, feature) {
          };
          VectorContext2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
          };
          VectorContext2.prototype.setImageStyle = function(imageStyle, opt_declutterImageWithText) {
          };
          VectorContext2.prototype.setTextStyle = function(textStyle, opt_declutterImageWithText) {
          };
          return VectorContext2;
        }()
      );
      var VectorContext$1 = VectorContext;
      function buffer(extent, value, opt_extent) {
        if (opt_extent) {
          opt_extent[0] = extent[0] - value;
          opt_extent[1] = extent[1] - value;
          opt_extent[2] = extent[2] + value;
          opt_extent[3] = extent[3] + value;
          return opt_extent;
        } else {
          return [
            extent[0] - value,
            extent[1] - value,
            extent[2] + value,
            extent[3] + value
          ];
        }
      }
      function clone(extent, opt_extent) {
        if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
        } else {
          return extent.slice();
        }
      }
      function closestSquaredDistanceXY(extent, x, y) {
        var dx, dy;
        if (x < extent[0]) {
          dx = extent[0] - x;
        } else if (extent[2] < x) {
          dx = x - extent[2];
        } else {
          dx = 0;
        }
        if (y < extent[1]) {
          dy = extent[1] - y;
        } else if (extent[3] < y) {
          dy = y - extent[3];
        } else {
          dy = 0;
        }
        return dx * dx + dy * dy;
      }
      function containsCoordinate(extent, coordinate) {
        return containsXY(extent, coordinate[0], coordinate[1]);
      }
      function containsExtent(extent1, extent2) {
        return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
      }
      function containsXY(extent, x, y) {
        return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
      }
      function coordinateRelationship(extent, coordinate) {
        var minX = extent[0];
        var minY = extent[1];
        var maxX = extent[2];
        var maxY = extent[3];
        var x = coordinate[0];
        var y = coordinate[1];
        var relationship = Relationship.UNKNOWN;
        if (x < minX) {
          relationship = relationship | Relationship.LEFT;
        } else if (x > maxX) {
          relationship = relationship | Relationship.RIGHT;
        }
        if (y < minY) {
          relationship = relationship | Relationship.BELOW;
        } else if (y > maxY) {
          relationship = relationship | Relationship.ABOVE;
        }
        if (relationship === Relationship.UNKNOWN) {
          relationship = Relationship.INTERSECTING;
        }
        return relationship;
      }
      function createEmpty() {
        return [Infinity, Infinity, -Infinity, -Infinity];
      }
      function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
        if (opt_extent) {
          opt_extent[0] = minX;
          opt_extent[1] = minY;
          opt_extent[2] = maxX;
          opt_extent[3] = maxY;
          return opt_extent;
        } else {
          return [minX, minY, maxX, maxY];
        }
      }
      function createOrUpdateEmpty(opt_extent) {
        return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
      }
      function createOrUpdateFromCoordinate(coordinate, opt_extent) {
        var x = coordinate[0];
        var y = coordinate[1];
        return createOrUpdate(x, y, x, y, opt_extent);
      }
      function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
        var extent = createOrUpdateEmpty(opt_extent);
        return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
      }
      function equals(extent1, extent2) {
        return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
      }
      function extendCoordinate(extent, coordinate) {
        if (coordinate[0] < extent[0]) {
          extent[0] = coordinate[0];
        }
        if (coordinate[0] > extent[2]) {
          extent[2] = coordinate[0];
        }
        if (coordinate[1] < extent[1]) {
          extent[1] = coordinate[1];
        }
        if (coordinate[1] > extent[3]) {
          extent[3] = coordinate[1];
        }
      }
      function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
        for (; offset < end; offset += stride) {
          extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
        }
        return extent;
      }
      function extendXY(extent, x, y) {
        extent[0] = Math.min(extent[0], x);
        extent[1] = Math.min(extent[1], y);
        extent[2] = Math.max(extent[2], x);
        extent[3] = Math.max(extent[3], y);
      }
      function getBottomLeft(extent) {
        return [extent[0], extent[1]];
      }
      function getBottomRight(extent) {
        return [extent[2], extent[1]];
      }
      function getCenter(extent) {
        return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
      }
      function getHeight(extent) {
        return extent[3] - extent[1];
      }
      function getTopLeft(extent) {
        return [extent[0], extent[3]];
      }
      function getTopRight(extent) {
        return [extent[2], extent[3]];
      }
      function getWidth(extent) {
        return extent[2] - extent[0];
      }
      function intersects(extent1, extent2) {
        return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
      }
      function returnOrUpdate(extent, opt_extent) {
        if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
        } else {
          return extent;
        }
      }
      function wrapX$1(extent, projection) {
        var projectionExtent = projection.getExtent();
        var center = getCenter(extent);
        if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
          var worldWidth = getWidth(projectionExtent);
          var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
          var offset = worldsAway * worldWidth;
          extent[0] -= offset;
          extent[2] -= offset;
        }
        return extent;
      }
      function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
        var coordinates = opt_coordinates !== void 0 ? opt_coordinates : [];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
          coordinates[i++] = flatCoordinates.slice(j, j + stride);
        }
        coordinates.length = i;
        return coordinates;
      }
      function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
        var coordinatess = opt_coordinatess !== void 0 ? opt_coordinatess : [];
        var i = 0;
        for (var j = 0, jj = ends.length; j < jj; ++j) {
          var end = ends[j];
          coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
          offset = end;
        }
        coordinatess.length = i;
        return coordinatess;
      }
      function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
        var coordinatesss = opt_coordinatesss !== void 0 ? opt_coordinatesss : [];
        var i = 0;
        for (var j = 0, jj = endss.length; j < jj; ++j) {
          var ends = endss[j];
          coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
          offset = ends[ends.length - 1];
        }
        coordinatesss.length = i;
        return coordinatesss;
      }
      var __extends$o = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var CanvasBuilder = (
        /** @class */
        function(_super) {
          __extends$o(CanvasBuilder2, _super);
          function CanvasBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this) || this;
            _this.tolerance = tolerance;
            _this.maxExtent = maxExtent;
            _this.pixelRatio = pixelRatio;
            _this.maxLineWidth = 0;
            _this.resolution = resolution;
            _this.beginGeometryInstruction1_ = null;
            _this.beginGeometryInstruction2_ = null;
            _this.bufferedMaxExtent_ = null;
            _this.instructions = [];
            _this.coordinates = [];
            _this.tmpCoordinate_ = [];
            _this.hitDetectionInstructions = [];
            _this.state = /** @type {import("../canvas.js").FillStrokeState} */
            {};
            return _this;
          }
          CanvasBuilder2.prototype.applyPixelRatio = function(dashArray) {
            var pixelRatio = this.pixelRatio;
            return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
              return dash * pixelRatio;
            });
          };
          CanvasBuilder2.prototype.appendFlatPointCoordinates = function(flatCoordinates, stride) {
            var extent = this.getBufferedMaxExtent();
            var tmpCoord = this.tmpCoordinate_;
            var coordinates = this.coordinates;
            var myEnd = coordinates.length;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              tmpCoord[0] = flatCoordinates[i];
              tmpCoord[1] = flatCoordinates[i + 1];
              if (containsCoordinate(extent, tmpCoord)) {
                coordinates[myEnd++] = tmpCoord[0];
                coordinates[myEnd++] = tmpCoord[1];
              }
            }
            return myEnd;
          };
          CanvasBuilder2.prototype.appendFlatLineCoordinates = function(flatCoordinates, offset, end, stride, closed, skipFirst) {
            var coordinates = this.coordinates;
            var myEnd = coordinates.length;
            var extent = this.getBufferedMaxExtent();
            if (skipFirst) {
              offset += stride;
            }
            var lastXCoord = flatCoordinates[offset];
            var lastYCoord = flatCoordinates[offset + 1];
            var nextCoord = this.tmpCoordinate_;
            var skipped = true;
            var i, lastRel, nextRel;
            for (i = offset + stride; i < end; i += stride) {
              nextCoord[0] = flatCoordinates[i];
              nextCoord[1] = flatCoordinates[i + 1];
              nextRel = coordinateRelationship(extent, nextCoord);
              if (nextRel !== lastRel) {
                if (skipped) {
                  coordinates[myEnd++] = lastXCoord;
                  coordinates[myEnd++] = lastYCoord;
                  skipped = false;
                }
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
              } else if (nextRel === Relationship.INTERSECTING) {
                coordinates[myEnd++] = nextCoord[0];
                coordinates[myEnd++] = nextCoord[1];
                skipped = false;
              } else {
                skipped = true;
              }
              lastXCoord = nextCoord[0];
              lastYCoord = nextCoord[1];
              lastRel = nextRel;
            }
            if (closed && skipped || i === offset + stride) {
              coordinates[myEnd++] = lastXCoord;
              coordinates[myEnd++] = lastYCoord;
            }
            return myEnd;
          };
          CanvasBuilder2.prototype.drawCustomCoordinates_ = function(flatCoordinates, offset, ends, stride, builderEnds) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var builderEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
              builderEnds.push(builderEnd);
              offset = end;
            }
            return offset;
          };
          CanvasBuilder2.prototype.drawCustom = function(geometry, feature, renderer, hitDetectionRenderer) {
            this.beginGeometry(geometry, feature);
            var type = geometry.getType();
            var stride = geometry.getStride();
            var builderBegin = this.coordinates.length;
            var flatCoordinates, builderEnd, builderEnds, builderEndss;
            var offset;
            switch (type) {
              case GeometryType.MULTI_POLYGON:
                flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
                geometry.getOrientedFlatCoordinates();
                builderEndss = [];
                var endss = (
                  /** @type {import("../../geom/MultiPolygon.js").default} */
                  geometry.getEndss()
                );
                offset = 0;
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var myEnds = [];
                  offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                  builderEndss.push(myEnds);
                }
                this.instructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEndss,
                  geometry,
                  renderer,
                  inflateMultiCoordinatesArray
                ]);
                this.hitDetectionInstructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEndss,
                  geometry,
                  hitDetectionRenderer || renderer,
                  inflateMultiCoordinatesArray
                ]);
                break;
              case GeometryType.POLYGON:
              case GeometryType.MULTI_LINE_STRING:
                builderEnds = [];
                flatCoordinates = type == GeometryType.POLYGON ? (
                  /** @type {import("../../geom/Polygon.js").default} */
                  geometry.getOrientedFlatCoordinates()
                ) : geometry.getFlatCoordinates();
                offset = this.drawCustomCoordinates_(
                  flatCoordinates,
                  0,
                  /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
                  geometry.getEnds(),
                  stride,
                  builderEnds
                );
                this.instructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEnds,
                  geometry,
                  renderer,
                  inflateCoordinatesArray
                ]);
                this.hitDetectionInstructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEnds,
                  geometry,
                  hitDetectionRenderer || renderer,
                  inflateCoordinatesArray
                ]);
                break;
              case GeometryType.LINE_STRING:
              case GeometryType.CIRCLE:
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
                this.instructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
                  inflateCoordinates
                ]);
                this.hitDetectionInstructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  hitDetectionRenderer || renderer,
                  inflateCoordinates
                ]);
                break;
              case GeometryType.MULTI_POINT:
                flatCoordinates = geometry.getFlatCoordinates();
                builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
                if (builderEnd > builderBegin) {
                  this.instructions.push([
                    CanvasInstruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    renderer,
                    inflateCoordinates
                  ]);
                  this.hitDetectionInstructions.push([
                    CanvasInstruction.CUSTOM,
                    builderBegin,
                    builderEnd,
                    geometry,
                    hitDetectionRenderer || renderer,
                    inflateCoordinates
                  ]);
                }
                break;
              case GeometryType.POINT:
                flatCoordinates = geometry.getFlatCoordinates();
                this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
                builderEnd = this.coordinates.length;
                this.instructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer
                ]);
                this.hitDetectionInstructions.push([
                  CanvasInstruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  hitDetectionRenderer || renderer
                ]);
                break;
            }
            this.endGeometry(feature);
          };
          CanvasBuilder2.prototype.beginGeometry = function(geometry, feature) {
            this.beginGeometryInstruction1_ = [
              CanvasInstruction.BEGIN_GEOMETRY,
              feature,
              0,
              geometry
            ];
            this.instructions.push(this.beginGeometryInstruction1_);
            this.beginGeometryInstruction2_ = [
              CanvasInstruction.BEGIN_GEOMETRY,
              feature,
              0,
              geometry
            ];
            this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
          };
          CanvasBuilder2.prototype.finish = function() {
            return {
              instructions: this.instructions,
              hitDetectionInstructions: this.hitDetectionInstructions,
              coordinates: this.coordinates
            };
          };
          CanvasBuilder2.prototype.reverseHitDetectionInstructions = function() {
            var hitDetectionInstructions = this.hitDetectionInstructions;
            hitDetectionInstructions.reverse();
            var i;
            var n = hitDetectionInstructions.length;
            var instruction;
            var type;
            var begin = -1;
            for (i = 0; i < n; ++i) {
              instruction = hitDetectionInstructions[i];
              type = /** @type {import("./Instruction.js").default} */
              instruction[0];
              if (type == CanvasInstruction.END_GEOMETRY) {
                begin = i;
              } else if (type == CanvasInstruction.BEGIN_GEOMETRY) {
                instruction[2] = i;
                reverseSubArray(this.hitDetectionInstructions, begin, i);
                begin = -1;
              }
            }
          };
          CanvasBuilder2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
            var state = this.state;
            if (fillStyle) {
              var fillStyleColor = fillStyle.getColor();
              state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
            } else {
              state.fillStyle = void 0;
            }
            if (strokeStyle) {
              var strokeStyleColor = strokeStyle.getColor();
              state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
              var strokeStyleLineCap = strokeStyle.getLineCap();
              state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
              var strokeStyleLineDash = strokeStyle.getLineDash();
              state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
              var strokeStyleWidth = strokeStyle.getWidth();
              state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
              if (state.lineWidth > this.maxLineWidth) {
                this.maxLineWidth = state.lineWidth;
                this.bufferedMaxExtent_ = null;
              }
            } else {
              state.strokeStyle = void 0;
              state.lineCap = void 0;
              state.lineDash = null;
              state.lineDashOffset = void 0;
              state.lineJoin = void 0;
              state.lineWidth = void 0;
              state.miterLimit = void 0;
            }
          };
          CanvasBuilder2.prototype.createFill = function(state) {
            var fillStyle = state.fillStyle;
            var fillInstruction2 = [CanvasInstruction.SET_FILL_STYLE, fillStyle];
            if (typeof fillStyle !== "string") {
              fillInstruction2.push(true);
            }
            return fillInstruction2;
          };
          CanvasBuilder2.prototype.applyStroke = function(state) {
            this.instructions.push(this.createStroke(state));
          };
          CanvasBuilder2.prototype.createStroke = function(state) {
            return [
              CanvasInstruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth * this.pixelRatio,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              this.applyPixelRatio(state.lineDash),
              state.lineDashOffset * this.pixelRatio
            ];
          };
          CanvasBuilder2.prototype.updateFillStyle = function(state, createFill) {
            var fillStyle = state.fillStyle;
            if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
              if (fillStyle !== void 0) {
                this.instructions.push(createFill.call(this, state));
              }
              state.currentFillStyle = fillStyle;
            }
          };
          CanvasBuilder2.prototype.updateStrokeStyle = function(state, applyStroke) {
            var strokeStyle = state.strokeStyle;
            var lineCap = state.lineCap;
            var lineDash = state.lineDash;
            var lineDashOffset = state.lineDashOffset;
            var lineJoin = state.lineJoin;
            var lineWidth = state.lineWidth;
            var miterLimit = state.miterLimit;
            if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals$1(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
              if (strokeStyle !== void 0) {
                applyStroke.call(this, state);
              }
              state.currentStrokeStyle = strokeStyle;
              state.currentLineCap = lineCap;
              state.currentLineDash = lineDash;
              state.currentLineDashOffset = lineDashOffset;
              state.currentLineJoin = lineJoin;
              state.currentLineWidth = lineWidth;
              state.currentMiterLimit = miterLimit;
            }
          };
          CanvasBuilder2.prototype.endGeometry = function(feature) {
            this.beginGeometryInstruction1_[2] = this.instructions.length;
            this.beginGeometryInstruction1_ = null;
            this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
            this.beginGeometryInstruction2_ = null;
            var endGeometryInstruction = [CanvasInstruction.END_GEOMETRY, feature];
            this.instructions.push(endGeometryInstruction);
            this.hitDetectionInstructions.push(endGeometryInstruction);
          };
          CanvasBuilder2.prototype.getBufferedMaxExtent = function() {
            if (!this.bufferedMaxExtent_) {
              this.bufferedMaxExtent_ = clone(this.maxExtent);
              if (this.maxLineWidth > 0) {
                var width = this.resolution * (this.maxLineWidth + 1) / 2;
                buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
              }
            }
            return this.bufferedMaxExtent_;
          };
          return CanvasBuilder2;
        }(VectorContext$1)
      );
      var Builder = CanvasBuilder;
      var __extends$n = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var CanvasImageBuilder = (
        /** @class */
        function(_super) {
          __extends$n(CanvasImageBuilder2, _super);
          function CanvasImageBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
            _this.hitDetectionImage_ = null;
            _this.image_ = null;
            _this.imagePixelRatio_ = void 0;
            _this.anchorX_ = void 0;
            _this.anchorY_ = void 0;
            _this.height_ = void 0;
            _this.opacity_ = void 0;
            _this.originX_ = void 0;
            _this.originY_ = void 0;
            _this.rotateWithView_ = void 0;
            _this.rotation_ = void 0;
            _this.scale_ = void 0;
            _this.width_ = void 0;
            _this.declutterImageWithText_ = void 0;
            return _this;
          }
          CanvasImageBuilder2.prototype.drawPoint = function(pointGeometry, feature) {
            if (!this.image_) {
              return;
            }
            this.beginGeometry(pointGeometry, feature);
            var flatCoordinates = pointGeometry.getFlatCoordinates();
            var stride = pointGeometry.getStride();
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            this.instructions.push([
              CanvasInstruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
              this.declutterImageWithText_
            ]);
            this.hitDetectionInstructions.push([
              CanvasInstruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
              this.declutterImageWithText_
            ]);
            this.endGeometry(feature);
          };
          CanvasImageBuilder2.prototype.drawMultiPoint = function(multiPointGeometry, feature) {
            if (!this.image_) {
              return;
            }
            this.beginGeometry(multiPointGeometry, feature);
            var flatCoordinates = multiPointGeometry.getFlatCoordinates();
            var stride = multiPointGeometry.getStride();
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            this.instructions.push([
              CanvasInstruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
                this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
              this.declutterImageWithText_
            ]);
            this.hitDetectionInstructions.push([
              CanvasInstruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
              this.declutterImageWithText_
            ]);
            this.endGeometry(feature);
          };
          CanvasImageBuilder2.prototype.finish = function() {
            this.reverseHitDetectionInstructions();
            this.anchorX_ = void 0;
            this.anchorY_ = void 0;
            this.hitDetectionImage_ = null;
            this.image_ = null;
            this.imagePixelRatio_ = void 0;
            this.height_ = void 0;
            this.scale_ = void 0;
            this.opacity_ = void 0;
            this.originX_ = void 0;
            this.originY_ = void 0;
            this.rotateWithView_ = void 0;
            this.rotation_ = void 0;
            this.width_ = void 0;
            return _super.prototype.finish.call(this);
          };
          CanvasImageBuilder2.prototype.setImageStyle = function(imageStyle, opt_sharedData) {
            var anchor = imageStyle.getAnchor();
            var size = imageStyle.getSize();
            var hitDetectionImage = imageStyle.getHitDetectionImage();
            var image = imageStyle.getImage(this.pixelRatio);
            var origin = imageStyle.getOrigin();
            this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
            this.anchorX_ = anchor[0];
            this.anchorY_ = anchor[1];
            this.hitDetectionImage_ = hitDetectionImage;
            this.image_ = image;
            this.height_ = size[1];
            this.opacity_ = imageStyle.getOpacity();
            this.originX_ = origin[0] * this.imagePixelRatio_;
            this.originY_ = origin[1] * this.imagePixelRatio_;
            this.rotateWithView_ = imageStyle.getRotateWithView();
            this.rotation_ = imageStyle.getRotation();
            this.scale_ = imageStyle.getScaleArray();
            this.width_ = size[0];
            this.declutterImageWithText_ = opt_sharedData;
          };
          return CanvasImageBuilder2;
        }(Builder)
      );
      var ImageBuilder = CanvasImageBuilder;
      var __extends$m = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var CanvasLineStringBuilder = (
        /** @class */
        function(_super) {
          __extends$m(CanvasLineStringBuilder2, _super);
          function CanvasLineStringBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
            return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          }
          CanvasLineStringBuilder2.prototype.drawFlatCoordinates_ = function(flatCoordinates, offset, end, stride) {
            var myBegin = this.coordinates.length;
            var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, false, false);
            var moveToLineToInstruction = [
              CanvasInstruction.MOVE_TO_LINE_TO,
              myBegin,
              myEnd
            ];
            this.instructions.push(moveToLineToInstruction);
            this.hitDetectionInstructions.push(moveToLineToInstruction);
            return end;
          };
          CanvasLineStringBuilder2.prototype.drawLineString = function(lineStringGeometry, feature) {
            var state = this.state;
            var strokeStyle = state.strokeStyle;
            var lineWidth = state.lineWidth;
            if (strokeStyle === void 0 || lineWidth === void 0) {
              return;
            }
            this.updateStrokeStyle(state, this.applyStroke);
            this.beginGeometry(lineStringGeometry, feature);
            this.hitDetectionInstructions.push([
              CanvasInstruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              defaultLineDash,
              defaultLineDashOffset
            ], beginPathInstruction);
            var flatCoordinates = lineStringGeometry.getFlatCoordinates();
            var stride = lineStringGeometry.getStride();
            this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
            this.hitDetectionInstructions.push(strokeInstruction);
            this.endGeometry(feature);
          };
          CanvasLineStringBuilder2.prototype.drawMultiLineString = function(multiLineStringGeometry, feature) {
            var state = this.state;
            var strokeStyle = state.strokeStyle;
            var lineWidth = state.lineWidth;
            if (strokeStyle === void 0 || lineWidth === void 0) {
              return;
            }
            this.updateStrokeStyle(state, this.applyStroke);
            this.beginGeometry(multiLineStringGeometry, feature);
            this.hitDetectionInstructions.push([
              CanvasInstruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset
            ], beginPathInstruction);
            var ends = multiLineStringGeometry.getEnds();
            var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
            var stride = multiLineStringGeometry.getStride();
            var offset = 0;
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.drawFlatCoordinates_(
                flatCoordinates,
                offset,
                /** @type {number} */
                ends[i],
                stride
              );
            }
            this.hitDetectionInstructions.push(strokeInstruction);
            this.endGeometry(feature);
          };
          CanvasLineStringBuilder2.prototype.finish = function() {
            var state = this.state;
            if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
            }
            this.reverseHitDetectionInstructions();
            this.state = null;
            return _super.prototype.finish.call(this);
          };
          CanvasLineStringBuilder2.prototype.applyStroke = function(state) {
            if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
              state.lastStroke = this.coordinates.length;
            }
            state.lastStroke = 0;
            _super.prototype.applyStroke.call(this, state);
            this.instructions.push(beginPathInstruction);
          };
          return CanvasLineStringBuilder2;
        }(Builder)
      );
      var LineStringBuilder = CanvasLineStringBuilder;
      function snap(value, tolerance) {
        return tolerance * Math.round(value / tolerance);
      }
      var __extends$l = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var CanvasPolygonBuilder = (
        /** @class */
        function(_super) {
          __extends$l(CanvasPolygonBuilder2, _super);
          function CanvasPolygonBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
            return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          }
          CanvasPolygonBuilder2.prototype.drawFlatCoordinatess_ = function(flatCoordinates, offset, ends, stride) {
            var state = this.state;
            var fill = state.fillStyle !== void 0;
            var stroke = state.strokeStyle !== void 0;
            var numEnds = ends.length;
            this.instructions.push(beginPathInstruction);
            this.hitDetectionInstructions.push(beginPathInstruction);
            for (var i = 0; i < numEnds; ++i) {
              var end = ends[i];
              var myBegin = this.coordinates.length;
              var myEnd = this.appendFlatLineCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
              var moveToLineToInstruction = [
                CanvasInstruction.MOVE_TO_LINE_TO,
                myBegin,
                myEnd
              ];
              this.instructions.push(moveToLineToInstruction);
              this.hitDetectionInstructions.push(moveToLineToInstruction);
              if (stroke) {
                this.instructions.push(closePathInstruction);
                this.hitDetectionInstructions.push(closePathInstruction);
              }
              offset = end;
            }
            if (fill) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
            }
            if (stroke) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
            }
            return offset;
          };
          CanvasPolygonBuilder2.prototype.drawCircle = function(circleGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === void 0 && strokeStyle === void 0) {
              return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(circleGeometry, feature);
            if (state.fillStyle !== void 0) {
              this.hitDetectionInstructions.push([
                CanvasInstruction.SET_FILL_STYLE,
                defaultFillStyle
              ]);
            }
            if (state.strokeStyle !== void 0) {
              this.hitDetectionInstructions.push([
                CanvasInstruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset
              ]);
            }
            var flatCoordinates = circleGeometry.getFlatCoordinates();
            var stride = circleGeometry.getStride();
            var myBegin = this.coordinates.length;
            this.appendFlatLineCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
            var circleInstruction = [CanvasInstruction.CIRCLE, myBegin];
            this.instructions.push(beginPathInstruction, circleInstruction);
            this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
            if (state.fillStyle !== void 0) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
            }
            if (state.strokeStyle !== void 0) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
            }
            this.endGeometry(feature);
          };
          CanvasPolygonBuilder2.prototype.drawPolygon = function(polygonGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === void 0 && strokeStyle === void 0) {
              return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(polygonGeometry, feature);
            if (state.fillStyle !== void 0) {
              this.hitDetectionInstructions.push([
                CanvasInstruction.SET_FILL_STYLE,
                defaultFillStyle
              ]);
            }
            if (state.strokeStyle !== void 0) {
              this.hitDetectionInstructions.push([
                CanvasInstruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset
              ]);
            }
            var ends = polygonGeometry.getEnds();
            var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
            var stride = polygonGeometry.getStride();
            this.drawFlatCoordinatess_(
              flatCoordinates,
              0,
              /** @type {Array<number>} */
              ends,
              stride
            );
            this.endGeometry(feature);
          };
          CanvasPolygonBuilder2.prototype.drawMultiPolygon = function(multiPolygonGeometry, feature) {
            var state = this.state;
            var fillStyle = state.fillStyle;
            var strokeStyle = state.strokeStyle;
            if (fillStyle === void 0 && strokeStyle === void 0) {
              return;
            }
            this.setFillStrokeStyles_();
            this.beginGeometry(multiPolygonGeometry, feature);
            if (state.fillStyle !== void 0) {
              this.hitDetectionInstructions.push([
                CanvasInstruction.SET_FILL_STYLE,
                defaultFillStyle
              ]);
            }
            if (state.strokeStyle !== void 0) {
              this.hitDetectionInstructions.push([
                CanvasInstruction.SET_STROKE_STYLE,
                state.strokeStyle,
                state.lineWidth,
                state.lineCap,
                state.lineJoin,
                state.miterLimit,
                state.lineDash,
                state.lineDashOffset
              ]);
            }
            var endss = multiPolygonGeometry.getEndss();
            var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
            var stride = multiPolygonGeometry.getStride();
            var offset = 0;
            for (var i = 0, ii = endss.length; i < ii; ++i) {
              offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
            }
            this.endGeometry(feature);
          };
          CanvasPolygonBuilder2.prototype.finish = function() {
            this.reverseHitDetectionInstructions();
            this.state = null;
            var tolerance = this.tolerance;
            if (tolerance !== 0) {
              var coordinates = this.coordinates;
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                coordinates[i] = snap(coordinates[i], tolerance);
              }
            }
            return _super.prototype.finish.call(this);
          };
          CanvasPolygonBuilder2.prototype.setFillStrokeStyles_ = function() {
            var state = this.state;
            var fillStyle = state.fillStyle;
            if (fillStyle !== void 0) {
              this.updateFillStyle(state, this.createFill);
            }
            if (state.strokeStyle !== void 0) {
              this.updateStrokeStyle(state, this.applyStroke);
            }
          };
          return CanvasPolygonBuilder2;
        }(Builder)
      );
      var PolygonBuilder = CanvasPolygonBuilder;
      var TextPlacement = {
        POINT: "point",
        LINE: "line"
      };
      function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
        var chunkStart = offset;
        var chunkEnd = offset;
        var chunkM = 0;
        var m = 0;
        var start = offset;
        var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
        for (i = offset; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          if (x1 !== void 0) {
            x23 = x2 - x1;
            y23 = y2 - y1;
            m23 = Math.sqrt(x23 * x23 + y23 * y23);
            if (x12 !== void 0) {
              m += m12;
              acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
              if (acos > maxAngle) {
                if (m > chunkM) {
                  chunkM = m;
                  chunkStart = start;
                  chunkEnd = i;
                }
                m = 0;
                start = i - stride;
              }
            }
            m12 = m23;
            x12 = x23;
            y12 = y23;
          }
          x1 = x2;
          y1 = y2;
        }
        m += m23;
        return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
      }
      var __extends$k = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var TEXT_ALIGN = {
        "left": 0,
        "end": 0,
        "center": 0.5,
        "right": 1,
        "start": 1,
        "top": 0,
        "middle": 0.5,
        "hanging": 0.2,
        "alphabetic": 0.8,
        "ideographic": 0.8,
        "bottom": 1
      };
      var CanvasTextBuilder = (
        /** @class */
        function(_super) {
          __extends$k(CanvasTextBuilder2, _super);
          function CanvasTextBuilder2(tolerance, maxExtent, resolution, pixelRatio) {
            var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
            _this.labels_ = null;
            _this.text_ = "";
            _this.textOffsetX_ = 0;
            _this.textOffsetY_ = 0;
            _this.textRotateWithView_ = void 0;
            _this.textRotation_ = 0;
            _this.textFillState_ = null;
            _this.fillStates = {};
            _this.textStrokeState_ = null;
            _this.strokeStates = {};
            _this.textState_ = /** @type {import("../canvas.js").TextState} */
            {};
            _this.textStates = {};
            _this.textKey_ = "";
            _this.fillKey_ = "";
            _this.strokeKey_ = "";
            _this.declutterImageWithText_ = void 0;
            return _this;
          }
          CanvasTextBuilder2.prototype.finish = function() {
            var instructions = _super.prototype.finish.call(this);
            instructions.textStates = this.textStates;
            instructions.fillStates = this.fillStates;
            instructions.strokeStates = this.strokeStates;
            return instructions;
          };
          CanvasTextBuilder2.prototype.drawText = function(geometry, feature) {
            var fillState = this.textFillState_;
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            if (this.text_ === "" || !textState || !fillState && !strokeState) {
              return;
            }
            var coordinates = this.coordinates;
            var begin = coordinates.length;
            var geometryType = geometry.getType();
            var flatCoordinates = null;
            var stride = geometry.getStride();
            if (textState.placement === TextPlacement.LINE && (geometryType == GeometryType.LINE_STRING || geometryType == GeometryType.MULTI_LINE_STRING || geometryType == GeometryType.POLYGON || geometryType == GeometryType.MULTI_POLYGON)) {
              if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
                return;
              }
              var ends = void 0;
              flatCoordinates = geometry.getFlatCoordinates();
              if (geometryType == GeometryType.LINE_STRING) {
                ends = [flatCoordinates.length];
              } else if (geometryType == GeometryType.MULTI_LINE_STRING) {
                ends = /** @type {import("../../geom/MultiLineString.js").default} */
                geometry.getEnds();
              } else if (geometryType == GeometryType.POLYGON) {
                ends = /** @type {import("../../geom/Polygon.js").default} */
                geometry.getEnds().slice(0, 1);
              } else if (geometryType == GeometryType.MULTI_POLYGON) {
                var endss = (
                  /** @type {import("../../geom/MultiPolygon.js").default} */
                  geometry.getEndss()
                );
                ends = [];
                for (var i = 0, ii = endss.length; i < ii; ++i) {
                  ends.push(endss[i][0]);
                }
              }
              this.beginGeometry(geometry, feature);
              var textAlign = textState.textAlign;
              var flatOffset = 0;
              var flatEnd = void 0;
              for (var o = 0, oo = ends.length; o < oo; ++o) {
                if (textAlign == void 0) {
                  var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                  flatOffset = range[0];
                  flatEnd = range[1];
                } else {
                  flatEnd = ends[o];
                }
                for (var i = flatOffset; i < flatEnd; i += stride) {
                  coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                }
                var end = coordinates.length;
                flatOffset = ends[o];
                this.drawChars_(begin, end);
                begin = end;
              }
              this.endGeometry(feature);
            } else {
              var geometryWidths = textState.overflow ? null : [];
              switch (geometryType) {
                case GeometryType.POINT:
                case GeometryType.MULTI_POINT:
                  flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
                  geometry.getFlatCoordinates();
                  break;
                case GeometryType.LINE_STRING:
                  flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
                  geometry.getFlatMidpoint();
                  break;
                case GeometryType.CIRCLE:
                  flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
                  geometry.getCenter();
                  break;
                case GeometryType.MULTI_LINE_STRING:
                  flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
                  geometry.getFlatMidpoints();
                  stride = 2;
                  break;
                case GeometryType.POLYGON:
                  flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
                  geometry.getFlatInteriorPoint();
                  if (!textState.overflow) {
                    geometryWidths.push(flatCoordinates[2] / this.resolution);
                  }
                  stride = 3;
                  break;
                case GeometryType.MULTI_POLYGON:
                  var interiorPoints = (
                    /** @type {import("../../geom/MultiPolygon.js").default} */
                    geometry.getFlatInteriorPoints()
                  );
                  flatCoordinates = [];
                  for (var i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                    if (!textState.overflow) {
                      geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                    }
                    flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                  }
                  if (flatCoordinates.length === 0) {
                    return;
                  }
                  stride = 2;
                  break;
              }
              var end = this.appendFlatPointCoordinates(flatCoordinates, stride);
              if (end === begin) {
                return;
              }
              if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
                var beg_1 = begin / 2;
                geometryWidths = geometryWidths.filter(function(w, i2) {
                  var keep = coordinates[(beg_1 + i2) * 2] === flatCoordinates[i2 * stride] && coordinates[(beg_1 + i2) * 2 + 1] === flatCoordinates[i2 * stride + 1];
                  if (!keep) {
                    --beg_1;
                  }
                  return keep;
                });
              }
              this.saveTextStates_();
              if (textState.backgroundFill || textState.backgroundStroke) {
                this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                if (textState.backgroundFill) {
                  this.updateFillStyle(this.state, this.createFill);
                  this.hitDetectionInstructions.push(this.createFill(this.state));
                }
                if (textState.backgroundStroke) {
                  this.updateStrokeStyle(this.state, this.applyStroke);
                  this.hitDetectionInstructions.push(this.createStroke(this.state));
                }
              }
              this.beginGeometry(geometry, feature);
              var padding = textState.padding;
              if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                var p0 = textState.padding[0];
                var p12 = textState.padding[1];
                var p22 = textState.padding[2];
                var p32 = textState.padding[3];
                if (textState.scale[0] < 0) {
                  p12 = -p12;
                  p32 = -p32;
                }
                if (textState.scale[1] < 0) {
                  p0 = -p0;
                  p22 = -p22;
                }
                padding = [p0, p12, p22, p32];
              }
              var pixelRatio_1 = this.pixelRatio;
              this.instructions.push([
                CanvasInstruction.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [1, 1],
                NaN,
                this.declutterImageWithText_,
                padding == defaultPadding ? defaultPadding : padding.map(function(p) {
                  return p * pixelRatio_1;
                }),
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
              ]);
              var scale2 = 1 / pixelRatio_1;
              this.hitDetectionInstructions.push([
                CanvasInstruction.DRAW_IMAGE,
                begin,
                end,
                null,
                NaN,
                NaN,
                NaN,
                1,
                0,
                0,
                this.textRotateWithView_,
                this.textRotation_,
                [scale2, scale2],
                NaN,
                this.declutterImageWithText_,
                padding,
                !!textState.backgroundFill,
                !!textState.backgroundStroke,
                this.text_,
                this.textKey_,
                this.strokeKey_,
                this.fillKey_,
                this.textOffsetX_,
                this.textOffsetY_,
                geometryWidths
              ]);
              this.endGeometry(feature);
            }
          };
          CanvasTextBuilder2.prototype.saveTextStates_ = function() {
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            var fillState = this.textFillState_;
            var strokeKey = this.strokeKey_;
            if (strokeState) {
              if (!(strokeKey in this.strokeStates)) {
                this.strokeStates[strokeKey] = {
                  strokeStyle: strokeState.strokeStyle,
                  lineCap: strokeState.lineCap,
                  lineDashOffset: strokeState.lineDashOffset,
                  lineWidth: strokeState.lineWidth,
                  lineJoin: strokeState.lineJoin,
                  miterLimit: strokeState.miterLimit,
                  lineDash: strokeState.lineDash
                };
              }
            }
            var textKey = this.textKey_;
            if (!(textKey in this.textStates)) {
              this.textStates[textKey] = {
                font: textState.font,
                textAlign: textState.textAlign || defaultTextAlign,
                textBaseline: textState.textBaseline || defaultTextBaseline,
                scale: textState.scale
              };
            }
            var fillKey = this.fillKey_;
            if (fillState) {
              if (!(fillKey in this.fillStates)) {
                this.fillStates[fillKey] = {
                  fillStyle: fillState.fillStyle
                };
              }
            }
          };
          CanvasTextBuilder2.prototype.drawChars_ = function(begin, end) {
            var strokeState = this.textStrokeState_;
            var textState = this.textState_;
            var strokeKey = this.strokeKey_;
            var textKey = this.textKey_;
            var fillKey = this.fillKey_;
            this.saveTextStates_();
            var pixelRatio = this.pixelRatio;
            var baseline = TEXT_ALIGN[textState.textBaseline];
            var offsetY = this.textOffsetY_ * pixelRatio;
            var text = this.text_;
            var strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
            this.instructions.push([
              CanvasInstruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              pixelRatio,
              offsetY,
              strokeKey,
              strokeWidth * pixelRatio,
              text,
              textKey,
              1
            ]);
            this.hitDetectionInstructions.push([
              CanvasInstruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              1,
              offsetY,
              strokeKey,
              strokeWidth,
              text,
              textKey,
              1 / pixelRatio
            ]);
          };
          CanvasTextBuilder2.prototype.setTextStyle = function(textStyle, opt_sharedData) {
            var textState, fillState, strokeState;
            if (!textStyle) {
              this.text_ = "";
            } else {
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                fillState = null;
                this.textFillState_ = fillState;
              } else {
                fillState = this.textFillState_;
                if (!fillState) {
                  fillState = /** @type {import("../canvas.js").FillState} */
                  {};
                  this.textFillState_ = fillState;
                }
                fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                strokeState = null;
                this.textStrokeState_ = strokeState;
              } else {
                strokeState = this.textStrokeState_;
                if (!strokeState) {
                  strokeState = /** @type {import("../canvas.js").StrokeState} */
                  {};
                  this.textStrokeState_ = strokeState;
                }
                var lineDash = textStrokeStyle.getLineDash();
                var lineDashOffset = textStrokeStyle.getLineDashOffset();
                var lineWidth = textStrokeStyle.getWidth();
                var miterLimit = textStrokeStyle.getMiterLimit();
                strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
                strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
                strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
                strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
                strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
                strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
                strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
              }
              textState = this.textState_;
              var font = textStyle.getFont() || defaultFont;
              registerFont(font);
              var textScale = textStyle.getScaleArray();
              textState.overflow = textStyle.getOverflow();
              textState.font = font;
              textState.maxAngle = textStyle.getMaxAngle();
              textState.placement = textStyle.getPlacement();
              textState.textAlign = textStyle.getTextAlign();
              textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
              textState.backgroundFill = textStyle.getBackgroundFill();
              textState.backgroundStroke = textStyle.getBackgroundStroke();
              textState.padding = textStyle.getPadding() || defaultPadding;
              textState.scale = textScale === void 0 ? [1, 1] : textScale;
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              this.text_ = textStyle.getText() || "";
              this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
              this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
              this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
              this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
              this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
              this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.textBaseline || "?");
              this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
            }
            this.declutterImageWithText_ = opt_sharedData;
          };
          return CanvasTextBuilder2;
        }(Builder)
      );
      var TextBuilder = CanvasTextBuilder;
      var BATCH_CONSTRUCTORS = {
        "Circle": PolygonBuilder,
        "Default": Builder,
        "Image": ImageBuilder,
        "LineString": LineStringBuilder,
        "Polygon": PolygonBuilder,
        "Text": TextBuilder
      };
      var BuilderGroup = (
        /** @class */
        function() {
          function BuilderGroup2(tolerance, maxExtent, resolution, pixelRatio) {
            this.tolerance_ = tolerance;
            this.maxExtent_ = maxExtent;
            this.pixelRatio_ = pixelRatio;
            this.resolution_ = resolution;
            this.buildersByZIndex_ = {};
          }
          BuilderGroup2.prototype.finish = function() {
            var builderInstructions = {};
            for (var zKey in this.buildersByZIndex_) {
              builderInstructions[zKey] = builderInstructions[zKey] || {};
              var builders = this.buildersByZIndex_[zKey];
              for (var builderKey in builders) {
                var builderInstruction = builders[builderKey].finish();
                builderInstructions[zKey][builderKey] = builderInstruction;
              }
            }
            return builderInstructions;
          };
          BuilderGroup2.prototype.getBuilder = function(zIndex, builderType) {
            var zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
            var replays = this.buildersByZIndex_[zIndexKey];
            if (replays === void 0) {
              replays = {};
              this.buildersByZIndex_[zIndexKey] = replays;
            }
            var replay = replays[builderType];
            if (replay === void 0) {
              var Constructor = BATCH_CONSTRUCTORS[builderType];
              replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
              replays[builderType] = replay;
            }
            return replay;
          };
          return BuilderGroup2;
        }()
      );
      var CanvasBuilderGroup = BuilderGroup;
      var __extends$j = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var LayerRenderer = (
        /** @class */
        function(_super) {
          __extends$j(LayerRenderer2, _super);
          function LayerRenderer2(layer) {
            var _this = _super.call(this) || this;
            _this.ready = true;
            _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
            _this.layer_ = layer;
            _this.declutterExecutorGroup = null;
            return _this;
          }
          LayerRenderer2.prototype.getFeatures = function(pixel) {
            return abstract();
          };
          LayerRenderer2.prototype.getData = function(pixel) {
            return null;
          };
          LayerRenderer2.prototype.prepareFrame = function(frameState) {
            return abstract();
          };
          LayerRenderer2.prototype.renderFrame = function(frameState, target) {
            return abstract();
          };
          LayerRenderer2.prototype.loadedTileCallback = function(tiles, zoom, tile) {
            if (!tiles[zoom]) {
              tiles[zoom] = {};
            }
            tiles[zoom][tile.tileCoord.toString()] = tile;
            return void 0;
          };
          LayerRenderer2.prototype.createLoadedTileFinder = function(source, projection, tiles) {
            return (
              /**
               * @param {number} zoom Zoom level.
               * @param {import("../TileRange.js").default} tileRange Tile range.
               * @return {boolean} The tile range is fully loaded.
               * @this {LayerRenderer}
               */
              (function(zoom, tileRange) {
                var callback = this.loadedTileCallback.bind(this, tiles, zoom);
                return source.forEachLoadedTile(projection, zoom, tileRange, callback);
              }).bind(this)
            );
          };
          LayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
            return void 0;
          };
          LayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
            return null;
          };
          LayerRenderer2.prototype.getLayer = function() {
            return this.layer_;
          };
          LayerRenderer2.prototype.handleFontsChanged = function() {
          };
          LayerRenderer2.prototype.handleImageChange_ = function(event) {
            var image = (
              /** @type {import("../Image.js").default} */
              event.target
            );
            if (image.getState() === ImageState.LOADED) {
              this.renderIfReadyAndVisible();
            }
          };
          LayerRenderer2.prototype.loadImage = function(image) {
            var imageState = image.getState();
            if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
              image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
            }
            if (imageState == ImageState.IDLE) {
              image.load();
              imageState = image.getState();
            }
            return imageState == ImageState.LOADED;
          };
          LayerRenderer2.prototype.renderIfReadyAndVisible = function() {
            var layer = this.getLayer();
            if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {
              layer.changed();
            }
          };
          LayerRenderer2.prototype.disposeInternal = function() {
            delete this.layer_;
            _super.prototype.disposeInternal.call(this);
          };
          return LayerRenderer2;
        }(Observable$1)
      );
      var LayerRenderer$1 = LayerRenderer;
      var __extends$i = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var RenderEvent = (
        /** @class */
        function(_super) {
          __extends$i(RenderEvent2, _super);
          function RenderEvent2(type, opt_inversePixelTransform, opt_frameState, opt_context) {
            var _this = _super.call(this, type) || this;
            _this.inversePixelTransform = opt_inversePixelTransform;
            _this.frameState = opt_frameState;
            _this.context = opt_context;
            return _this;
          }
          return RenderEvent2;
        }(Event)
      );
      var RenderEvent$1 = RenderEvent;
      new Array(6);
      function create() {
        return [1, 0, 0, 1, 0, 0];
      }
      function set(transform2, a, b, c, d, e, f) {
        transform2[0] = a;
        transform2[1] = b;
        transform2[2] = c;
        transform2[3] = d;
        transform2[4] = e;
        transform2[5] = f;
        return transform2;
      }
      function setFromArray(transform1, transform2) {
        transform1[0] = transform2[0];
        transform1[1] = transform2[1];
        transform1[2] = transform2[2];
        transform1[3] = transform2[3];
        transform1[4] = transform2[4];
        transform1[5] = transform2[5];
        return transform1;
      }
      function apply(transform2, coordinate) {
        var x = coordinate[0];
        var y = coordinate[1];
        coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
        coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
        return coordinate;
      }
      function makeScale(target, x, y) {
        return set(target, x, 0, 0, y, 0, 0);
      }
      function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
        var sin = Math.sin(angle);
        var cos = Math.cos(angle);
        transform2[0] = sx * cos;
        transform2[1] = sy * sin;
        transform2[2] = -sx * sin;
        transform2[3] = sy * cos;
        transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
        transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
        return transform2;
      }
      function makeInverse(target, source) {
        var det = determinant(source);
        assert(det !== 0, 32);
        var a = source[0];
        var b = source[1];
        var c = source[2];
        var d = source[3];
        var e = source[4];
        var f = source[5];
        target[0] = d / det;
        target[1] = -b / det;
        target[2] = -c / det;
        target[3] = a / det;
        target[4] = (c * f - d * e) / det;
        target[5] = -(a * f - b * e) / det;
        return target;
      }
      function determinant(mat) {
        return mat[0] * mat[3] - mat[1] * mat[2];
      }
      var transformStringDiv;
      function toString(mat) {
        var transformString = "matrix(" + mat.join(", ") + ")";
        if (WORKER_OFFSCREEN_CANVAS) {
          return transformString;
        }
        var node = transformStringDiv || (transformStringDiv = document.createElement("div"));
        node.style.transform = transformString;
        return node.style.transform;
      }
      var __extends$h = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var pixelContext = null;
      function createPixelContext() {
        var canvas = document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        pixelContext = canvas.getContext("2d");
      }
      var CanvasLayerRenderer = (
        /** @class */
        function(_super) {
          __extends$h(CanvasLayerRenderer2, _super);
          function CanvasLayerRenderer2(layer) {
            var _this = _super.call(this, layer) || this;
            _this.container = null;
            _this.renderedResolution;
            _this.tempTransform = create();
            _this.pixelTransform = create();
            _this.inversePixelTransform = create();
            _this.context = null;
            _this.containerReused = false;
            _this.pixelContext_ = null;
            _this.frameState = null;
            return _this;
          }
          CanvasLayerRenderer2.prototype.getImageData = function(image, col, row) {
            if (!pixelContext) {
              createPixelContext();
            }
            pixelContext.clearRect(0, 0, 1, 1);
            var data;
            try {
              pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
              data = pixelContext.getImageData(0, 0, 1, 1).data;
            } catch (err) {
              return null;
            }
            return data;
          };
          CanvasLayerRenderer2.prototype.getBackground = function(frameState) {
            var layer = this.getLayer();
            var background = layer.getBackground();
            if (typeof background === "function") {
              background = background(frameState.viewState.resolution);
            }
            return background || void 0;
          };
          CanvasLayerRenderer2.prototype.useContainer = function(target, transform2, opacity, opt_backgroundColor) {
            var layerClassName = this.getLayer().getClassName();
            var container, context;
            if (target && target.className === layerClassName && target.style.opacity === "" && opacity === 1 && (!opt_backgroundColor || target.style.backgroundColor && equals$1(asArray(target.style.backgroundColor), asArray(opt_backgroundColor)))) {
              var canvas = target.firstElementChild;
              if (canvas instanceof HTMLCanvasElement) {
                context = canvas.getContext("2d");
              }
            }
            if (context && context.canvas.style.transform === transform2) {
              this.container = target;
              this.context = context;
              this.containerReused = true;
            } else if (this.containerReused) {
              this.container = null;
              this.context = null;
              this.containerReused = false;
            }
            if (!this.container) {
              container = document.createElement("div");
              container.className = layerClassName;
              var style = container.style;
              style.position = "absolute";
              style.width = "100%";
              style.height = "100%";
              if (opt_backgroundColor) {
                style.backgroundColor = opt_backgroundColor;
              }
              context = createCanvasContext2D();
              var canvas = context.canvas;
              container.appendChild(canvas);
              style = canvas.style;
              style.position = "absolute";
              style.left = "0";
              style.transformOrigin = "top left";
              this.container = container;
              this.context = context;
            }
          };
          CanvasLayerRenderer2.prototype.clipUnrotated = function(context, frameState, extent) {
            var topLeft = getTopLeft(extent);
            var topRight = getTopRight(extent);
            var bottomRight = getBottomRight(extent);
            var bottomLeft = getBottomLeft(extent);
            apply(frameState.coordinateToPixelTransform, topLeft);
            apply(frameState.coordinateToPixelTransform, topRight);
            apply(frameState.coordinateToPixelTransform, bottomRight);
            apply(frameState.coordinateToPixelTransform, bottomLeft);
            var inverted = this.inversePixelTransform;
            apply(inverted, topLeft);
            apply(inverted, topRight);
            apply(inverted, bottomRight);
            apply(inverted, bottomLeft);
            context.save();
            context.beginPath();
            context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
            context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
            context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
            context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
            context.clip();
          };
          CanvasLayerRenderer2.prototype.dispatchRenderEvent_ = function(type, context, frameState) {
            var layer = this.getLayer();
            if (layer.hasListener(type)) {
              var event_1 = new RenderEvent$1(type, this.inversePixelTransform, frameState, context);
              layer.dispatchEvent(event_1);
            }
          };
          CanvasLayerRenderer2.prototype.preRender = function(context, frameState) {
            this.frameState = frameState;
            this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
          };
          CanvasLayerRenderer2.prototype.postRender = function(context, frameState) {
            this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
          };
          CanvasLayerRenderer2.prototype.getRenderTransform = function(center, resolution, rotation, pixelRatio, width, height, offsetX) {
            var dx1 = width / 2;
            var dy1 = height / 2;
            var sx = pixelRatio / resolution;
            var sy = -sx;
            var dx2 = -center[0] + offsetX;
            var dy2 = -center[1];
            return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
          };
          CanvasLayerRenderer2.prototype.getDataAtPixel = function(pixel, frameState, hitTolerance) {
            var renderPixel = apply(this.inversePixelTransform, pixel.slice());
            var context = this.context;
            var layer = this.getLayer();
            var layerExtent = layer.getExtent();
            if (layerExtent) {
              var renderCoordinate = apply(frameState.pixelToCoordinateTransform, pixel.slice());
              if (!containsCoordinate(layerExtent, renderCoordinate)) {
                return null;
              }
            }
            var x = Math.round(renderPixel[0]);
            var y = Math.round(renderPixel[1]);
            var pixelContext2 = this.pixelContext_;
            if (!pixelContext2) {
              var pixelCanvas = document.createElement("canvas");
              pixelCanvas.width = 1;
              pixelCanvas.height = 1;
              pixelContext2 = pixelCanvas.getContext("2d");
              this.pixelContext_ = pixelContext2;
            }
            pixelContext2.clearRect(0, 0, 1, 1);
            var data;
            try {
              pixelContext2.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
              data = pixelContext2.getImageData(0, 0, 1, 1).data;
            } catch (err) {
              if (err.name === "SecurityError") {
                this.pixelContext_ = null;
                return new Uint8Array();
              }
              return data;
            }
            if (data[3] === 0) {
              return null;
            }
            return data;
          };
          CanvasLayerRenderer2.prototype.disposeInternal = function() {
            delete this.frameState;
            _super.prototype.disposeInternal.call(this);
          };
          return CanvasLayerRenderer2;
        }(LayerRenderer$1)
      );
      var CanvasLayerRenderer$1 = CanvasLayerRenderer;
      var BuilderType = {
        CIRCLE: "Circle",
        DEFAULT: "Default",
        IMAGE: "Image",
        LINE_STRING: "LineString",
        POLYGON: "Polygon",
        TEXT: "Text"
      };
      function transform2D(flatCoordinates, offset, end, stride, transform2, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
          var x = flatCoordinates[j];
          var y = flatCoordinates[j + 1];
          dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
          dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
        }
        if (opt_dest && dest.length != i) {
          dest.length = i;
        }
        return dest;
      }
      function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var anchorX = anchor[0];
        var anchorY = anchor[1];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + deltaX * cos - deltaY * sin;
          dest[i++] = anchorY + deltaX * sin + deltaY * cos;
          for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
          }
        }
        if (opt_dest && dest.length != i) {
          dest.length = i;
        }
        return dest;
      }
      function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var anchorX = anchor[0];
        var anchorY = anchor[1];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + sx * deltaX;
          dest[i++] = anchorY + sy * deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
          }
        }
        if (opt_dest && dest.length != i) {
          dest.length = i;
        }
        return dest;
      }
      function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
        var dest = opt_dest ? opt_dest : [];
        var i = 0;
        for (var j = offset; j < end; j += stride) {
          dest[i++] = flatCoordinates[j] + deltaX;
          dest[i++] = flatCoordinates[j + 1] + deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
            dest[i++] = flatCoordinates[k];
          }
        }
        if (opt_dest && dest.length != i) {
          dest.length = i;
        }
        return dest;
      }
      function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale2, measureAndCacheTextWidth2, font, cache2, rotation) {
        var x2 = flatCoordinates[offset];
        var y2 = flatCoordinates[offset + 1];
        var x1 = 0;
        var y1 = 0;
        var segmentLength = 0;
        var segmentM = 0;
        function advance() {
          x1 = x2;
          y1 = y2;
          offset += stride;
          x2 = flatCoordinates[offset];
          y2 = flatCoordinates[offset + 1];
          segmentM += segmentLength;
          segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        }
        do {
          advance();
        } while (offset < end - stride && segmentM + segmentLength < startM);
        var interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
        var beginX = lerp(x1, x2, interpolate);
        var beginY = lerp(y1, y2, interpolate);
        var startOffset = offset - stride;
        var startLength = segmentM;
        var endM = startM + scale2 * measureAndCacheTextWidth2(font, text, cache2);
        while (offset < end - stride && segmentM + segmentLength < endM) {
          advance();
        }
        interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
        var endX = lerp(x1, x2, interpolate);
        var endY = lerp(y1, y2, interpolate);
        var reverse;
        if (rotation) {
          var flat = [beginX, beginY, endX, endY];
          rotate(flat, 0, 4, 2, rotation, flat, flat);
          reverse = flat[0] > flat[2];
        } else {
          reverse = beginX > endX;
        }
        var PI = Math.PI;
        var result = [];
        var singleSegment = startOffset + stride === offset;
        offset = startOffset;
        segmentLength = 0;
        segmentM = startLength;
        x2 = flatCoordinates[offset];
        y2 = flatCoordinates[offset + 1];
        var previousAngle;
        if (singleSegment) {
          advance();
          previousAngle = Math.atan2(y2 - y1, x2 - x1);
          if (reverse) {
            previousAngle += previousAngle > 0 ? -PI : PI;
          }
          var x = (endX + beginX) / 2;
          var y = (endY + beginY) / 2;
          result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
          return result;
        }
        for (var i = 0, ii = text.length; i < ii; ) {
          advance();
          var angle = Math.atan2(y2 - y1, x2 - x1);
          if (reverse) {
            angle += angle > 0 ? -PI : PI;
          }
          if (previousAngle !== void 0) {
            var delta = angle - previousAngle;
            delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
            if (Math.abs(delta) > maxAngle) {
              return null;
            }
          }
          previousAngle = angle;
          var iStart = i;
          var charLength = 0;
          for (; i < ii; ++i) {
            var index = reverse ? ii - i - 1 : i;
            var len = scale2 * measureAndCacheTextWidth2(font, text[index], cache2);
            if (offset + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
              break;
            }
            charLength += len;
          }
          if (i === iStart) {
            continue;
          }
          var chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
          interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
          var x = lerp(x1, x2, interpolate);
          var y = lerp(y1, y2, interpolate);
          result.push([x, y, charLength / 2, angle, chars]);
          startM += charLength;
        }
        return result;
      }
      function lineStringLength(flatCoordinates, offset, end, stride) {
        var x1 = flatCoordinates[offset];
        var y1 = flatCoordinates[offset + 1];
        var length = 0;
        for (var i = offset + stride; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          x1 = x2;
          y1 = y2;
        }
        return length;
      }
      var tmpExtent = createEmpty();
      var p1 = [];
      var p2 = [];
      var p3 = [];
      var p4 = [];
      function getDeclutterBox(replayImageOrLabelArgs) {
        return replayImageOrLabelArgs[3].declutterBox;
      }
      var rtlRegEx = new RegExp(
        /* eslint-disable prettier/prettier */
        "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
        /* eslint-enable prettier/prettier */
      );
      function horizontalTextAlign(text, align) {
        if ((align === "start" || align === "end") && !rtlRegEx.test(text)) {
          align = align === "start" ? "left" : "right";
        }
        return TEXT_ALIGN[align];
      }
      function createTextChunks(acc, line, i) {
        if (i > 0) {
          acc.push("\n", "");
        }
        acc.push(line, "");
        return acc;
      }
      var Executor = (
        /** @class */
        function() {
          function Executor2(resolution, pixelRatio, overlaps, instructions) {
            this.overlaps = overlaps;
            this.pixelRatio = pixelRatio;
            this.resolution = resolution;
            this.alignFill_;
            this.instructions = instructions.instructions;
            this.coordinates = instructions.coordinates;
            this.coordinateCache_ = {};
            this.renderedTransform_ = create();
            this.hitDetectionInstructions = instructions.hitDetectionInstructions;
            this.pixelCoordinates_ = null;
            this.viewRotation_ = 0;
            this.fillStates = instructions.fillStates || {};
            this.strokeStates = instructions.strokeStates || {};
            this.textStates = instructions.textStates || {};
            this.widths_ = {};
            this.labels_ = {};
          }
          Executor2.prototype.createLabel = function(text, textKey, fillKey, strokeKey) {
            var key = text + textKey + fillKey + strokeKey;
            if (this.labels_[key]) {
              return this.labels_[key];
            }
            var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
            var fillState = fillKey ? this.fillStates[fillKey] : null;
            var textState = this.textStates[textKey];
            var pixelRatio = this.pixelRatio;
            var scale2 = [
              textState.scale[0] * pixelRatio,
              textState.scale[1] * pixelRatio
            ];
            var textIsArray = Array.isArray(text);
            var align = horizontalTextAlign(textIsArray ? text[0] : text, textState.textAlign || defaultTextAlign);
            var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
            var chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
            var _a = getTextDimensions(textState, chunks), width = _a.width, height = _a.height, widths = _a.widths, heights = _a.heights, lineWidths = _a.lineWidths;
            var renderWidth = width + strokeWidth;
            var contextInstructions = [];
            var w = (renderWidth + 2) * scale2[0];
            var h = (height + strokeWidth) * scale2[1];
            var label = {
              width: w < 0 ? Math.floor(w) : Math.ceil(w),
              height: h < 0 ? Math.floor(h) : Math.ceil(h),
              contextInstructions
            };
            if (scale2[0] != 1 || scale2[1] != 1) {
              contextInstructions.push("scale", scale2);
            }
            if (strokeKey) {
              contextInstructions.push("strokeStyle", strokeState.strokeStyle);
              contextInstructions.push("lineWidth", strokeWidth);
              contextInstructions.push("lineCap", strokeState.lineCap);
              contextInstructions.push("lineJoin", strokeState.lineJoin);
              contextInstructions.push("miterLimit", strokeState.miterLimit);
              var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
              if (Context.prototype.setLineDash) {
                contextInstructions.push("setLineDash", [strokeState.lineDash]);
                contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
              }
            }
            if (fillKey) {
              contextInstructions.push("fillStyle", fillState.fillStyle);
            }
            contextInstructions.push("textBaseline", "middle");
            contextInstructions.push("textAlign", "center");
            var leftRight = 0.5 - align;
            var x = align * renderWidth + leftRight * strokeWidth;
            var strokeInstructions = [];
            var fillInstructions = [];
            var lineHeight = 0;
            var lineOffset = 0;
            var widthHeightIndex = 0;
            var lineWidthIndex = 0;
            var previousFont;
            for (var i = 0, ii = chunks.length; i < ii; i += 2) {
              var text_1 = chunks[i];
              if (text_1 === "\n") {
                lineOffset += lineHeight;
                lineHeight = 0;
                x = align * renderWidth + leftRight * strokeWidth;
                ++lineWidthIndex;
                continue;
              }
              var font = chunks[i + 1] || textState.font;
              if (font !== previousFont) {
                if (strokeKey) {
                  strokeInstructions.push("font", font);
                }
                if (fillKey) {
                  fillInstructions.push("font", font);
                }
                previousFont = font;
              }
              lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
              var fillStrokeArgs = [
                text_1,
                x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
                0.5 * (strokeWidth + lineHeight) + lineOffset
              ];
              x += widths[widthHeightIndex];
              if (strokeKey) {
                strokeInstructions.push("strokeText", fillStrokeArgs);
              }
              if (fillKey) {
                fillInstructions.push("fillText", fillStrokeArgs);
              }
              ++widthHeightIndex;
            }
            Array.prototype.push.apply(contextInstructions, strokeInstructions);
            Array.prototype.push.apply(contextInstructions, fillInstructions);
            this.labels_[key] = label;
            return label;
          };
          Executor2.prototype.replayTextBackground_ = function(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
            context.beginPath();
            context.moveTo.apply(context, p12);
            context.lineTo.apply(context, p22);
            context.lineTo.apply(context, p32);
            context.lineTo.apply(context, p42);
            context.lineTo.apply(context, p12);
            if (fillInstruction2) {
              this.alignFill_ = /** @type {boolean} */
              fillInstruction2[2];
              this.fill_(context);
            }
            if (strokeInstruction2) {
              this.setStrokeStyle_(
                context,
                /** @type {Array<*>} */
                strokeInstruction2
              );
              context.stroke();
            }
          };
          Executor2.prototype.calculateImageOrLabelDimensions_ = function(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, fillStroke, feature) {
            anchorX *= scale2[0];
            anchorY *= scale2[1];
            var x = centerX - anchorX;
            var y = centerY - anchorY;
            var w = width + originX > sheetWidth ? sheetWidth - originX : width;
            var h = height + originY > sheetHeight ? sheetHeight - originY : height;
            var boxW = padding[3] + w * scale2[0] + padding[1];
            var boxH = padding[0] + h * scale2[1] + padding[2];
            var boxX = x - padding[3];
            var boxY = y - padding[0];
            if (fillStroke || rotation !== 0) {
              p1[0] = boxX;
              p4[0] = boxX;
              p1[1] = boxY;
              p2[1] = boxY;
              p2[0] = boxX + boxW;
              p3[0] = p2[0];
              p3[1] = boxY + boxH;
              p4[1] = p3[1];
            }
            var transform2;
            if (rotation !== 0) {
              transform2 = compose(create(), centerX, centerY, 1, 1, rotation, -centerX, -centerY);
              apply(transform2, p1);
              apply(transform2, p2);
              apply(transform2, p3);
              apply(transform2, p4);
              createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
            } else {
              createOrUpdate(Math.min(boxX, boxX + boxW), Math.min(boxY, boxY + boxH), Math.max(boxX, boxX + boxW), Math.max(boxY, boxY + boxH), tmpExtent);
            }
            if (snapToPixel) {
              x = Math.round(x);
              y = Math.round(y);
            }
            return {
              drawImageX: x,
              drawImageY: y,
              drawImageW: w,
              drawImageH: h,
              originX,
              originY,
              declutterBox: {
                minX: tmpExtent[0],
                minY: tmpExtent[1],
                maxX: tmpExtent[2],
                maxY: tmpExtent[3],
                value: feature
              },
              canvasTransform: transform2,
              scale: scale2
            };
          };
          Executor2.prototype.replayImageOrLabel_ = function(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
            var fillStroke = !!(fillInstruction2 || strokeInstruction2);
            var box = dimensions.declutterBox;
            var canvas = context.canvas;
            var strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
            var intersects2 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
            if (intersects2) {
              if (fillStroke) {
                this.replayTextBackground_(
                  context,
                  p1,
                  p2,
                  p3,
                  p4,
                  /** @type {Array<*>} */
                  fillInstruction2,
                  /** @type {Array<*>} */
                  strokeInstruction2
                );
              }
              drawImageOrLabel(context, dimensions.canvasTransform, opacity, imageOrLabel, dimensions.originX, dimensions.originY, dimensions.drawImageW, dimensions.drawImageH, dimensions.drawImageX, dimensions.drawImageY, dimensions.scale);
            }
            return true;
          };
          Executor2.prototype.fill_ = function(context) {
            if (this.alignFill_) {
              var origin_1 = apply(this.renderedTransform_, [0, 0]);
              var repeatSize = 512 * this.pixelRatio;
              context.save();
              context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
              context.rotate(this.viewRotation_);
            }
            context.fill();
            if (this.alignFill_) {
              context.restore();
            }
          };
          Executor2.prototype.setStrokeStyle_ = function(context, instruction) {
            context["strokeStyle"] = /** @type {import("../../colorlike.js").ColorLike} */
            instruction[1];
            context.lineWidth = /** @type {number} */
            instruction[2];
            context.lineCap = /** @type {CanvasLineCap} */
            instruction[3];
            context.lineJoin = /** @type {CanvasLineJoin} */
            instruction[4];
            context.miterLimit = /** @type {number} */
            instruction[5];
            if (context.setLineDash) {
              context.lineDashOffset = /** @type {number} */
              instruction[7];
              context.setLineDash(
                /** @type {Array<number>} */
                instruction[6]
              );
            }
          };
          Executor2.prototype.drawLabelWithPointPlacement_ = function(text, textKey, strokeKey, fillKey) {
            var textState = this.textStates[textKey];
            var label = this.createLabel(text, textKey, fillKey, strokeKey);
            var strokeState = this.strokeStates[strokeKey];
            var pixelRatio = this.pixelRatio;
            var align = horizontalTextAlign(Array.isArray(text) ? text[0] : text, textState.textAlign || defaultTextAlign);
            var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
            var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
            var width = label.width / pixelRatio - 2 * textState.scale[0];
            var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
            var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
            return {
              label,
              anchorX,
              anchorY
            };
          };
          Executor2.prototype.execute_ = function(context, contextScale, transform2, instructions, snapToPixel, opt_featureCallback, opt_hitExtent, opt_declutterTree) {
            var pixelCoordinates;
            if (this.pixelCoordinates_ && equals$1(transform2, this.renderedTransform_)) {
              pixelCoordinates = this.pixelCoordinates_;
            } else {
              if (!this.pixelCoordinates_) {
                this.pixelCoordinates_ = [];
              }
              pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform2, this.pixelCoordinates_);
              setFromArray(this.renderedTransform_, transform2);
            }
            var i = 0;
            var ii = instructions.length;
            var d = 0;
            var dd;
            var anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
            var pendingFill = 0;
            var pendingStroke = 0;
            var lastFillInstruction = null;
            var lastStrokeInstruction = null;
            var coordinateCache = this.coordinateCache_;
            var viewRotation = this.viewRotation_;
            var viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
            var state = (
              /** @type {import("../../render.js").State} */
              {
                context,
                pixelRatio: this.pixelRatio,
                resolution: this.resolution,
                rotation: viewRotation
              }
            );
            var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
            var feature;
            var x, y, currentGeometry;
            while (i < ii) {
              var instruction = instructions[i];
              var type = (
                /** @type {import("./Instruction.js").default} */
                instruction[0]
              );
              switch (type) {
                case CanvasInstruction.BEGIN_GEOMETRY:
                  feature = /** @type {import("../../Feature.js").FeatureLike} */
                  instruction[1];
                  currentGeometry = instruction[3];
                  if (!feature.getGeometry()) {
                    i = /** @type {number} */
                    instruction[2];
                  } else if (opt_hitExtent !== void 0 && !intersects(opt_hitExtent, currentGeometry.getExtent())) {
                    i = /** @type {number} */
                    instruction[2] + 1;
                  } else {
                    ++i;
                  }
                  break;
                case CanvasInstruction.BEGIN_PATH:
                  if (pendingFill > batchSize) {
                    this.fill_(context);
                    pendingFill = 0;
                  }
                  if (pendingStroke > batchSize) {
                    context.stroke();
                    pendingStroke = 0;
                  }
                  if (!pendingFill && !pendingStroke) {
                    context.beginPath();
                    prevX = NaN;
                    prevY = NaN;
                  }
                  ++i;
                  break;
                case CanvasInstruction.CIRCLE:
                  d = /** @type {number} */
                  instruction[1];
                  var x1 = pixelCoordinates[d];
                  var y1 = pixelCoordinates[d + 1];
                  var x2 = pixelCoordinates[d + 2];
                  var y2 = pixelCoordinates[d + 3];
                  var dx = x2 - x1;
                  var dy = y2 - y1;
                  var r = Math.sqrt(dx * dx + dy * dy);
                  context.moveTo(x1 + r, y1);
                  context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                  ++i;
                  break;
                case CanvasInstruction.CLOSE_PATH:
                  context.closePath();
                  ++i;
                  break;
                case CanvasInstruction.CUSTOM:
                  d = /** @type {number} */
                  instruction[1];
                  dd = instruction[2];
                  var geometry = (
                    /** @type {import("../../geom/SimpleGeometry.js").default} */
                    instruction[3]
                  );
                  var renderer = instruction[4];
                  var fn = instruction.length == 6 ? instruction[5] : void 0;
                  state.geometry = geometry;
                  state.feature = feature;
                  if (!(i in coordinateCache)) {
                    coordinateCache[i] = [];
                  }
                  var coords = coordinateCache[i];
                  if (fn) {
                    fn(pixelCoordinates, d, dd, 2, coords);
                  } else {
                    coords[0] = pixelCoordinates[d];
                    coords[1] = pixelCoordinates[d + 1];
                    coords.length = 2;
                  }
                  renderer(coords, state);
                  ++i;
                  break;
                case CanvasInstruction.DRAW_IMAGE:
                  d = /** @type {number} */
                  instruction[1];
                  dd = /** @type {number} */
                  instruction[2];
                  image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
                  instruction[3];
                  anchorX = /** @type {number} */
                  instruction[4];
                  anchorY = /** @type {number} */
                  instruction[5];
                  var height = (
                    /** @type {number} */
                    instruction[6]
                  );
                  var opacity = (
                    /** @type {number} */
                    instruction[7]
                  );
                  var originX = (
                    /** @type {number} */
                    instruction[8]
                  );
                  var originY = (
                    /** @type {number} */
                    instruction[9]
                  );
                  var rotateWithView = (
                    /** @type {boolean} */
                    instruction[10]
                  );
                  var rotation = (
                    /** @type {number} */
                    instruction[11]
                  );
                  var scale2 = (
                    /** @type {import("../../size.js").Size} */
                    instruction[12]
                  );
                  var width = (
                    /** @type {number} */
                    instruction[13]
                  );
                  var declutterImageWithText = (
                    /** @type {import("../canvas.js").DeclutterImageWithText} */
                    instruction[14]
                  );
                  if (!image && instruction.length >= 19) {
                    text = /** @type {string} */
                    instruction[18];
                    textKey = /** @type {string} */
                    instruction[19];
                    strokeKey = /** @type {string} */
                    instruction[20];
                    fillKey = /** @type {string} */
                    instruction[21];
                    var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                    image = labelWithAnchor.label;
                    instruction[3] = image;
                    var textOffsetX = (
                      /** @type {number} */
                      instruction[22]
                    );
                    anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                    instruction[4] = anchorX;
                    var textOffsetY = (
                      /** @type {number} */
                      instruction[23]
                    );
                    anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                    instruction[5] = anchorY;
                    height = image.height;
                    instruction[6] = height;
                    width = image.width;
                    instruction[13] = width;
                  }
                  var geometryWidths = void 0;
                  if (instruction.length > 24) {
                    geometryWidths = /** @type {number} */
                    instruction[24];
                  }
                  var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                  if (instruction.length > 16) {
                    padding = /** @type {Array<number>} */
                    instruction[15];
                    backgroundFill = /** @type {boolean} */
                    instruction[16];
                    backgroundStroke = /** @type {boolean} */
                    instruction[17];
                  } else {
                    padding = defaultPadding;
                    backgroundFill = false;
                    backgroundStroke = false;
                  }
                  if (rotateWithView && viewRotationFromTransform) {
                    rotation += viewRotation;
                  } else if (!rotateWithView && !viewRotationFromTransform) {
                    rotation -= viewRotation;
                  }
                  var widthIndex = 0;
                  for (; d < dd; d += 2) {
                    if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                      continue;
                    }
                    var dimensions = this.calculateImageOrLabelDimensions_(image.width, image.height, pixelCoordinates[d], pixelCoordinates[d + 1], width, height, anchorX, anchorY, originX, originY, rotation, scale2, snapToPixel, padding, backgroundFill || backgroundStroke, feature);
                    var args = [
                      context,
                      contextScale,
                      image,
                      dimensions,
                      opacity,
                      backgroundFill ? (
                        /** @type {Array<*>} */
                        lastFillInstruction
                      ) : null,
                      backgroundStroke ? (
                        /** @type {Array<*>} */
                        lastStrokeInstruction
                      ) : null
                    ];
                    var imageArgs = void 0;
                    var imageDeclutterBox = void 0;
                    if (opt_declutterTree && declutterImageWithText) {
                      var index = dd - d;
                      if (!declutterImageWithText[index]) {
                        declutterImageWithText[index] = args;
                        continue;
                      }
                      imageArgs = declutterImageWithText[index];
                      delete declutterImageWithText[index];
                      imageDeclutterBox = getDeclutterBox(imageArgs);
                      if (opt_declutterTree.collides(imageDeclutterBox)) {
                        continue;
                      }
                    }
                    if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                      continue;
                    }
                    if (imageArgs) {
                      if (opt_declutterTree) {
                        opt_declutterTree.insert(imageDeclutterBox);
                      }
                      this.replayImageOrLabel_.apply(this, imageArgs);
                    }
                    if (opt_declutterTree) {
                      opt_declutterTree.insert(dimensions.declutterBox);
                    }
                    this.replayImageOrLabel_.apply(this, args);
                  }
                  ++i;
                  break;
                case CanvasInstruction.DRAW_CHARS:
                  var begin = (
                    /** @type {number} */
                    instruction[1]
                  );
                  var end = (
                    /** @type {number} */
                    instruction[2]
                  );
                  var baseline = (
                    /** @type {number} */
                    instruction[3]
                  );
                  var overflow = (
                    /** @type {number} */
                    instruction[4]
                  );
                  fillKey = /** @type {string} */
                  instruction[5];
                  var maxAngle = (
                    /** @type {number} */
                    instruction[6]
                  );
                  var measurePixelRatio = (
                    /** @type {number} */
                    instruction[7]
                  );
                  var offsetY = (
                    /** @type {number} */
                    instruction[8]
                  );
                  strokeKey = /** @type {string} */
                  instruction[9];
                  var strokeWidth = (
                    /** @type {number} */
                    instruction[10]
                  );
                  text = /** @type {string} */
                  instruction[11];
                  textKey = /** @type {string} */
                  instruction[12];
                  var pixelRatioScale = [
                    /** @type {number} */
                    instruction[13],
                    /** @type {number} */
                    instruction[13]
                  ];
                  var textState = this.textStates[textKey];
                  var font = textState.font;
                  var textScale = [
                    textState.scale[0] * measurePixelRatio,
                    textState.scale[1] * measurePixelRatio
                  ];
                  var cachedWidths = void 0;
                  if (font in this.widths_) {
                    cachedWidths = this.widths_[font];
                  } else {
                    cachedWidths = {};
                    this.widths_[font] = cachedWidths;
                  }
                  var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
                  var textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
                  if (overflow || textLength <= pathLength) {
                    var textAlign = this.textStates[textKey].textAlign;
                    var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                    var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                    drawChars: if (parts) {
                      var replayImageOrLabelArgs = [];
                      var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                      if (strokeKey) {
                        for (c = 0, cc = parts.length; c < cc; ++c) {
                          part = parts[c];
                          chars = /** @type {string} */
                          part[4];
                          label = this.createLabel(chars, textKey, "", strokeKey);
                          anchorX = /** @type {number} */
                          part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                          anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                          var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                          if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                            break drawChars;
                          }
                          replayImageOrLabelArgs.push([
                            context,
                            contextScale,
                            label,
                            dimensions,
                            1,
                            null,
                            null
                          ]);
                        }
                      }
                      if (fillKey) {
                        for (c = 0, cc = parts.length; c < cc; ++c) {
                          part = parts[c];
                          chars = /** @type {string} */
                          part[4];
                          label = this.createLabel(chars, textKey, fillKey, "");
                          anchorX = /** @type {number} */
                          part[2];
                          anchorY = baseline * label.height - offsetY;
                          var dimensions = this.calculateImageOrLabelDimensions_(label.width, label.height, part[0], part[1], label.width, label.height, anchorX, anchorY, 0, 0, part[3], pixelRatioScale, false, defaultPadding, false, feature);
                          if (opt_declutterTree && opt_declutterTree.collides(dimensions.declutterBox)) {
                            break drawChars;
                          }
                          replayImageOrLabelArgs.push([
                            context,
                            contextScale,
                            label,
                            dimensions,
                            1,
                            null,
                            null
                          ]);
                        }
                      }
                      if (opt_declutterTree) {
                        opt_declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                      }
                      for (var i_1 = 0, ii_1 = replayImageOrLabelArgs.length; i_1 < ii_1; ++i_1) {
                        this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i_1]);
                      }
                    }
                  }
                  ++i;
                  break;
                case CanvasInstruction.END_GEOMETRY:
                  if (opt_featureCallback !== void 0) {
                    feature = /** @type {import("../../Feature.js").FeatureLike} */
                    instruction[1];
                    var result = opt_featureCallback(feature, currentGeometry);
                    if (result) {
                      return result;
                    }
                  }
                  ++i;
                  break;
                case CanvasInstruction.FILL:
                  if (batchSize) {
                    pendingFill++;
                  } else {
                    this.fill_(context);
                  }
                  ++i;
                  break;
                case CanvasInstruction.MOVE_TO_LINE_TO:
                  d = /** @type {number} */
                  instruction[1];
                  dd = /** @type {number} */
                  instruction[2];
                  x = pixelCoordinates[d];
                  y = pixelCoordinates[d + 1];
                  roundX = x + 0.5 | 0;
                  roundY = y + 0.5 | 0;
                  if (roundX !== prevX || roundY !== prevY) {
                    context.moveTo(x, y);
                    prevX = roundX;
                    prevY = roundY;
                  }
                  for (d += 2; d < dd; d += 2) {
                    x = pixelCoordinates[d];
                    y = pixelCoordinates[d + 1];
                    roundX = x + 0.5 | 0;
                    roundY = y + 0.5 | 0;
                    if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                      context.lineTo(x, y);
                      prevX = roundX;
                      prevY = roundY;
                    }
                  }
                  ++i;
                  break;
                case CanvasInstruction.SET_FILL_STYLE:
                  lastFillInstruction = instruction;
                  this.alignFill_ = instruction[2];
                  if (pendingFill) {
                    this.fill_(context);
                    pendingFill = 0;
                    if (pendingStroke) {
                      context.stroke();
                      pendingStroke = 0;
                    }
                  }
                  context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
                  instruction[1];
                  ++i;
                  break;
                case CanvasInstruction.SET_STROKE_STYLE:
                  lastStrokeInstruction = instruction;
                  if (pendingStroke) {
                    context.stroke();
                    pendingStroke = 0;
                  }
                  this.setStrokeStyle_(
                    context,
                    /** @type {Array<*>} */
                    instruction
                  );
                  ++i;
                  break;
                case CanvasInstruction.STROKE:
                  if (batchSize) {
                    pendingStroke++;
                  } else {
                    context.stroke();
                  }
                  ++i;
                  break;
                default:
                  ++i;
                  break;
              }
            }
            if (pendingFill) {
              this.fill_(context);
            }
            if (pendingStroke) {
              context.stroke();
            }
            return void 0;
          };
          Executor2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree) {
            this.viewRotation_ = viewRotation;
            this.execute_(context, contextScale, transform2, this.instructions, snapToPixel, void 0, void 0, opt_declutterTree);
          };
          Executor2.prototype.executeHitDetection = function(context, transform2, viewRotation, opt_featureCallback, opt_hitExtent) {
            this.viewRotation_ = viewRotation;
            return this.execute_(context, 1, transform2, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
          };
          return Executor2;
        }()
      );
      var Executor$1 = Executor;
      var ORDER = [
        BuilderType.POLYGON,
        BuilderType.CIRCLE,
        BuilderType.LINE_STRING,
        BuilderType.IMAGE,
        BuilderType.TEXT,
        BuilderType.DEFAULT
      ];
      var ExecutorGroup = (
        /** @class */
        function() {
          function ExecutorGroup2(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
            this.maxExtent_ = maxExtent;
            this.overlaps_ = overlaps;
            this.pixelRatio_ = pixelRatio;
            this.resolution_ = resolution;
            this.renderBuffer_ = opt_renderBuffer;
            this.executorsByZIndex_ = {};
            this.hitDetectionContext_ = null;
            this.hitDetectionTransform_ = create();
            this.createExecutors_(allInstructions);
          }
          ExecutorGroup2.prototype.clip = function(context, transform2) {
            var flatClipCoords = this.getClipCoords(transform2);
            context.beginPath();
            context.moveTo(flatClipCoords[0], flatClipCoords[1]);
            context.lineTo(flatClipCoords[2], flatClipCoords[3]);
            context.lineTo(flatClipCoords[4], flatClipCoords[5]);
            context.lineTo(flatClipCoords[6], flatClipCoords[7]);
            context.clip();
          };
          ExecutorGroup2.prototype.createExecutors_ = function(allInstructions) {
            for (var zIndex in allInstructions) {
              var executors = this.executorsByZIndex_[zIndex];
              if (executors === void 0) {
                executors = {};
                this.executorsByZIndex_[zIndex] = executors;
              }
              var instructionByZindex = allInstructions[zIndex];
              for (var builderType in instructionByZindex) {
                var instructions = instructionByZindex[builderType];
                executors[builderType] = new Executor$1(this.resolution_, this.pixelRatio_, this.overlaps_, instructions);
              }
            }
          };
          ExecutorGroup2.prototype.hasExecutors = function(executors) {
            for (var zIndex in this.executorsByZIndex_) {
              var candidates = this.executorsByZIndex_[zIndex];
              for (var i = 0, ii = executors.length; i < ii; ++i) {
                if (executors[i] in candidates) {
                  return true;
                }
              }
            }
            return false;
          };
          ExecutorGroup2.prototype.forEachFeatureAtCoordinate = function(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
            hitTolerance = Math.round(hitTolerance);
            var contextSize = hitTolerance * 2 + 1;
            var transform2 = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
            var newContext = !this.hitDetectionContext_;
            if (newContext) {
              this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
            }
            var context = this.hitDetectionContext_;
            if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
              context.canvas.width = contextSize;
              context.canvas.height = contextSize;
            } else if (!newContext) {
              context.clearRect(0, 0, contextSize, contextSize);
            }
            var hitExtent;
            if (this.renderBuffer_ !== void 0) {
              hitExtent = createEmpty();
              extendCoordinate(hitExtent, coordinate);
              buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
            }
            var indexes = getPixelIndexArray(hitTolerance);
            var builderType;
            function featureCallback(feature, geometry) {
              var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
              for (var i_1 = 0, ii = indexes.length; i_1 < ii; i_1++) {
                if (imageData[indexes[i_1]] > 0) {
                  if (!declutteredFeatures || builderType !== BuilderType.IMAGE && builderType !== BuilderType.TEXT || declutteredFeatures.indexOf(feature) !== -1) {
                    var idx = (indexes[i_1] - 3) / 4;
                    var x = hitTolerance - idx % contextSize;
                    var y = hitTolerance - (idx / contextSize | 0);
                    var result_1 = callback(feature, geometry, x * x + y * y);
                    if (result_1) {
                      return result_1;
                    }
                  }
                  context.clearRect(0, 0, contextSize, contextSize);
                  break;
                }
              }
              return void 0;
            }
            var zs = Object.keys(this.executorsByZIndex_).map(Number);
            zs.sort(numberSafeCompareFunction);
            var i, j, executors, executor, result;
            for (i = zs.length - 1; i >= 0; --i) {
              var zIndexKey = zs[i].toString();
              executors = this.executorsByZIndex_[zIndexKey];
              for (j = ORDER.length - 1; j >= 0; --j) {
                builderType = ORDER[j];
                executor = executors[builderType];
                if (executor !== void 0) {
                  result = executor.executeHitDetection(context, transform2, rotation, featureCallback, hitExtent);
                  if (result) {
                    return result;
                  }
                }
              }
            }
            return void 0;
          };
          ExecutorGroup2.prototype.getClipCoords = function(transform2) {
            var maxExtent = this.maxExtent_;
            if (!maxExtent) {
              return null;
            }
            var minX = maxExtent[0];
            var minY = maxExtent[1];
            var maxX = maxExtent[2];
            var maxY = maxExtent[3];
            var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
            transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
            return flatClipCoords;
          };
          ExecutorGroup2.prototype.isEmpty = function() {
            return isEmpty(this.executorsByZIndex_);
          };
          ExecutorGroup2.prototype.execute = function(context, contextScale, transform2, viewRotation, snapToPixel, opt_builderTypes, opt_declutterTree) {
            var zs = Object.keys(this.executorsByZIndex_).map(Number);
            zs.sort(numberSafeCompareFunction);
            if (this.maxExtent_) {
              context.save();
              this.clip(context, transform2);
            }
            var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
            var i, ii, j, jj, replays, replay;
            if (opt_declutterTree) {
              zs.reverse();
            }
            for (i = 0, ii = zs.length; i < ii; ++i) {
              var zIndexKey = zs[i].toString();
              replays = this.executorsByZIndex_[zIndexKey];
              for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                var builderType = builderTypes[j];
                replay = replays[builderType];
                if (replay !== void 0) {
                  replay.execute(context, contextScale, transform2, viewRotation, snapToPixel, opt_declutterTree);
                }
              }
            }
            if (this.maxExtent_) {
              context.restore();
            }
          };
          return ExecutorGroup2;
        }()
      );
      var circlePixelIndexArrayCache = {};
      function getPixelIndexArray(radius) {
        if (circlePixelIndexArrayCache[radius] !== void 0) {
          return circlePixelIndexArrayCache[radius];
        }
        var size = radius * 2 + 1;
        var maxDistanceSq = radius * radius;
        var distances = new Array(maxDistanceSq + 1);
        for (var i = 0; i <= radius; ++i) {
          for (var j = 0; j <= radius; ++j) {
            var distanceSq = i * i + j * j;
            if (distanceSq > maxDistanceSq) {
              break;
            }
            var distance = distances[distanceSq];
            if (!distance) {
              distance = [];
              distances[distanceSq] = distance;
            }
            distance.push(((radius + i) * size + (radius + j)) * 4 + 3);
            if (i > 0) {
              distance.push(((radius - i) * size + (radius + j)) * 4 + 3);
            }
            if (j > 0) {
              distance.push(((radius + i) * size + (radius - j)) * 4 + 3);
              if (i > 0) {
                distance.push(((radius - i) * size + (radius - j)) * 4 + 3);
              }
            }
          }
        }
        var pixelIndex = [];
        for (var i = 0, ii = distances.length; i < ii; ++i) {
          if (distances[i]) {
            pixelIndex.push.apply(pixelIndex, distances[i]);
          }
        }
        circlePixelIndexArrayCache[radius] = pixelIndex;
        return pixelIndex;
      }
      var ExecutorGroup$1 = ExecutorGroup;
      var ViewHint = {
        ANIMATING: 0,
        INTERACTING: 1
      };
      var Units = {
        /**
         * Radians
         * @api
         */
        RADIANS: "radians",
        /**
         * Degrees
         * @api
         */
        DEGREES: "degrees",
        /**
         * Feet
         * @api
         */
        FEET: "ft",
        /**
         * Meters
         * @api
         */
        METERS: "m",
        /**
         * Pixels
         * @api
         */
        PIXELS: "pixels",
        /**
         * Tile Pixels
         * @api
         */
        TILE_PIXELS: "tile-pixels",
        /**
         * US Feet
         * @api
         */
        USFEET: "us-ft"
      };
      var METERS_PER_UNIT$1 = {};
      METERS_PER_UNIT$1[Units.RADIANS] = 6370997 / (2 * Math.PI);
      METERS_PER_UNIT$1[Units.DEGREES] = 2 * Math.PI * 6370997 / 360;
      METERS_PER_UNIT$1[Units.FEET] = 0.3048;
      METERS_PER_UNIT$1[Units.METERS] = 1;
      METERS_PER_UNIT$1[Units.USFEET] = 1200 / 3937;
      var Units$1 = Units;
      var Projection = (
        /** @class */
        function() {
          function Projection2(options) {
            this.code_ = options.code;
            this.units_ = /** @type {import("./Units.js").default} */
            options.units;
            this.extent_ = options.extent !== void 0 ? options.extent : null;
            this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
            this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
            this.global_ = options.global !== void 0 ? options.global : false;
            this.canWrapX_ = !!(this.global_ && this.extent_);
            this.getPointResolutionFunc_ = options.getPointResolution;
            this.defaultTileGrid_ = null;
            this.metersPerUnit_ = options.metersPerUnit;
          }
          Projection2.prototype.canWrapX = function() {
            return this.canWrapX_;
          };
          Projection2.prototype.getCode = function() {
            return this.code_;
          };
          Projection2.prototype.getExtent = function() {
            return this.extent_;
          };
          Projection2.prototype.getUnits = function() {
            return this.units_;
          };
          Projection2.prototype.getMetersPerUnit = function() {
            return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
          };
          Projection2.prototype.getWorldExtent = function() {
            return this.worldExtent_;
          };
          Projection2.prototype.getAxisOrientation = function() {
            return this.axisOrientation_;
          };
          Projection2.prototype.isGlobal = function() {
            return this.global_;
          };
          Projection2.prototype.setGlobal = function(global) {
            this.global_ = global;
            this.canWrapX_ = !!(global && this.extent_);
          };
          Projection2.prototype.getDefaultTileGrid = function() {
            return this.defaultTileGrid_;
          };
          Projection2.prototype.setDefaultTileGrid = function(tileGrid) {
            this.defaultTileGrid_ = tileGrid;
          };
          Projection2.prototype.setExtent = function(extent) {
            this.extent_ = extent;
            this.canWrapX_ = !!(this.global_ && extent);
          };
          Projection2.prototype.setWorldExtent = function(worldExtent) {
            this.worldExtent_ = worldExtent;
          };
          Projection2.prototype.setGetPointResolution = function(func) {
            this.getPointResolutionFunc_ = func;
          };
          Projection2.prototype.getPointResolutionFunc = function() {
            return this.getPointResolutionFunc_;
          };
          return Projection2;
        }()
      );
      var Projection$1 = Projection;
      var __extends$g = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var RADIUS$1 = 6378137;
      var HALF_SIZE = Math.PI * RADIUS$1;
      var EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
      var WORLD_EXTENT = [-180, -85, 180, 85];
      var MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
      var EPSG3857Projection = (
        /** @class */
        function(_super) {
          __extends$g(EPSG3857Projection2, _super);
          function EPSG3857Projection2(code) {
            return _super.call(this, {
              code,
              units: Units$1.METERS,
              extent: EXTENT$1,
              global: true,
              worldExtent: WORLD_EXTENT,
              getPointResolution: function(resolution, point) {
                return resolution / cosh(point[1] / RADIUS$1);
              }
            }) || this;
          }
          return EPSG3857Projection2;
        }(Projection$1)
      );
      var PROJECTIONS$1 = [
        new EPSG3857Projection("EPSG:3857"),
        new EPSG3857Projection("EPSG:102100"),
        new EPSG3857Projection("EPSG:102113"),
        new EPSG3857Projection("EPSG:900913"),
        new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
        new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
      ];
      function fromEPSG4326(input, opt_output, opt_dimension) {
        var length = input.length;
        var dimension = opt_dimension > 1 ? opt_dimension : 2;
        var output = opt_output;
        if (output === void 0) {
          if (dimension > 2) {
            output = input.slice();
          } else {
            output = new Array(length);
          }
        }
        for (var i = 0; i < length; i += dimension) {
          output[i] = HALF_SIZE * input[i] / 180;
          var y = RADIUS$1 * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
          if (y > MAX_SAFE_Y) {
            y = MAX_SAFE_Y;
          } else if (y < -MAX_SAFE_Y) {
            y = -MAX_SAFE_Y;
          }
          output[i + 1] = y;
        }
        return output;
      }
      function toEPSG4326(input, opt_output, opt_dimension) {
        var length = input.length;
        var dimension = opt_dimension > 1 ? opt_dimension : 2;
        var output = opt_output;
        if (output === void 0) {
          if (dimension > 2) {
            output = input.slice();
          } else {
            output = new Array(length);
          }
        }
        for (var i = 0; i < length; i += dimension) {
          output[i] = 180 * input[i] / HALF_SIZE;
          output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS$1)) / Math.PI - 90;
        }
        return output;
      }
      var __extends$f = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var RADIUS = 6378137;
      var EXTENT = [-180, -90, 180, 90];
      var METERS_PER_UNIT = Math.PI * RADIUS / 180;
      var EPSG4326Projection = (
        /** @class */
        function(_super) {
          __extends$f(EPSG4326Projection2, _super);
          function EPSG4326Projection2(code, opt_axisOrientation) {
            return _super.call(this, {
              code,
              units: Units$1.DEGREES,
              extent: EXTENT,
              axisOrientation: opt_axisOrientation,
              global: true,
              metersPerUnit: METERS_PER_UNIT,
              worldExtent: EXTENT
            }) || this;
          }
          return EPSG4326Projection2;
        }(Projection$1)
      );
      var PROJECTIONS = [
        new EPSG4326Projection("CRS:84"),
        new EPSG4326Projection("EPSG:4326", "neu"),
        new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
        new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
        new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
        new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
        new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
      ];
      var cache = {};
      function get$3(code) {
        return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
      }
      function add$1(code, projection) {
        cache[code] = projection;
      }
      var transforms = {};
      function add(source, destination, transformFn) {
        var sourceCode = source.getCode();
        var destinationCode = destination.getCode();
        if (!(sourceCode in transforms)) {
          transforms[sourceCode] = {};
        }
        transforms[sourceCode][destinationCode] = transformFn;
      }
      function get$2(sourceCode, destinationCode) {
        var transform2;
        if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
          transform2 = transforms[sourceCode][destinationCode];
        }
        return transform2;
      }
      function wrapX(coordinate, projection) {
        if (projection.canWrapX()) {
          var worldWidth = getWidth(projection.getExtent());
          var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
          if (worldsAway) {
            coordinate[0] -= worldsAway * worldWidth;
          }
        }
        return coordinate;
      }
      function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
        var projectionExtent = projection.getExtent();
        var worldsAway = 0;
        if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
          var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
          worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
        }
        return worldsAway;
      }
      var DEFAULT_RADIUS = 63710088e-1;
      function getDistance(c1, c2, opt_radius) {
        var radius = opt_radius || DEFAULT_RADIUS;
        var lat1 = toRadians(c1[1]);
        var lat2 = toRadians(c2[1]);
        var deltaLatBy2 = (lat2 - lat1) / 2;
        var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
        var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
        return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }
      function cloneTransform(input, opt_output, opt_dimension) {
        var output;
        if (opt_output !== void 0) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
            opt_output[i] = input[i];
          }
          output = opt_output;
        } else {
          output = input.slice();
        }
        return output;
      }
      function identityTransform(input, opt_output, opt_dimension) {
        if (opt_output !== void 0 && input !== opt_output) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
            opt_output[i] = input[i];
          }
          input = opt_output;
        }
        return input;
      }
      function addProjection(projection) {
        add$1(projection.getCode(), projection);
        add(projection, projection, cloneTransform);
      }
      function addProjections(projections) {
        projections.forEach(addProjection);
      }
      function get$1(projectionLike) {
        return typeof projectionLike === "string" ? get$3(
          /** @type {string} */
          projectionLike
        ) : (
          /** @type {Projection} */
          projectionLike || null
        );
      }
      function addEquivalentProjections(projections) {
        addProjections(projections);
        projections.forEach(function(source) {
          projections.forEach(function(destination) {
            if (source !== destination) {
              add(source, destination, cloneTransform);
            }
          });
        });
      }
      function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
        projections1.forEach(function(projection1) {
          projections2.forEach(function(projection2) {
            add(projection1, projection2, forwardTransform);
            add(projection2, projection1, inverseTransform);
          });
        });
      }
      function getTransformFromProjections(sourceProjection, destinationProjection) {
        var sourceCode = sourceProjection.getCode();
        var destinationCode = destinationProjection.getCode();
        var transformFunc = get$2(sourceCode, destinationCode);
        if (!transformFunc) {
          transformFunc = identityTransform;
        }
        return transformFunc;
      }
      function getTransform(source, destination) {
        var sourceProjection = get$1(source);
        var destinationProjection = get$1(destination);
        return getTransformFromProjections(sourceProjection, destinationProjection);
      }
      function transform(coordinate, source, destination) {
        var transformFunc = getTransform(source, destination);
        return transformFunc(coordinate, void 0, coordinate.length);
      }
      function toUserExtent(extent, sourceProjection) {
        {
          return extent;
        }
      }
      function fromUserExtent(extent, destProjection) {
        {
          return extent;
        }
      }
      function addCommon() {
        addEquivalentProjections(PROJECTIONS$1);
        addEquivalentProjections(PROJECTIONS);
        addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326);
      }
      addCommon();
      var __extends$e = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var tmpTransform = create();
      var Geometry = (
        /** @class */
        function(_super) {
          __extends$e(Geometry2, _super);
          function Geometry2() {
            var _this = _super.call(this) || this;
            _this.extent_ = createEmpty();
            _this.extentRevision_ = -1;
            _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
            _this.simplifiedGeometryRevision = 0;
            _this.simplifyTransformedInternal = memoizeOne(function(revision, squaredTolerance, opt_transform) {
              if (!opt_transform) {
                return this.getSimplifiedGeometry(squaredTolerance);
              }
              var clone2 = this.clone();
              clone2.applyTransform(opt_transform);
              return clone2.getSimplifiedGeometry(squaredTolerance);
            });
            return _this;
          }
          Geometry2.prototype.simplifyTransformed = function(squaredTolerance, opt_transform) {
            return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
          };
          Geometry2.prototype.clone = function() {
            return abstract();
          };
          Geometry2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            return abstract();
          };
          Geometry2.prototype.containsXY = function(x, y) {
            var coord = this.getClosestPoint([x, y]);
            return coord[0] === x && coord[1] === y;
          };
          Geometry2.prototype.getClosestPoint = function(point, opt_closestPoint) {
            var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
            this.closestPointXY(point[0], point[1], closestPoint, Infinity);
            return closestPoint;
          };
          Geometry2.prototype.intersectsCoordinate = function(coordinate) {
            return this.containsXY(coordinate[0], coordinate[1]);
          };
          Geometry2.prototype.computeExtent = function(extent) {
            return abstract();
          };
          Geometry2.prototype.getExtent = function(opt_extent) {
            if (this.extentRevision_ != this.getRevision()) {
              var extent = this.computeExtent(this.extent_);
              if (isNaN(extent[0]) || isNaN(extent[1])) {
                createOrUpdateEmpty(extent);
              }
              this.extentRevision_ = this.getRevision();
            }
            return returnOrUpdate(this.extent_, opt_extent);
          };
          Geometry2.prototype.rotate = function(angle, anchor) {
            abstract();
          };
          Geometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {
            abstract();
          };
          Geometry2.prototype.simplify = function(tolerance) {
            return this.getSimplifiedGeometry(tolerance * tolerance);
          };
          Geometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
            return abstract();
          };
          Geometry2.prototype.getType = function() {
            return abstract();
          };
          Geometry2.prototype.applyTransform = function(transformFn) {
            abstract();
          };
          Geometry2.prototype.intersectsExtent = function(extent) {
            return abstract();
          };
          Geometry2.prototype.translate = function(deltaX, deltaY) {
            abstract();
          };
          Geometry2.prototype.transform = function(source, destination) {
            var sourceProj = get$1(source);
            var transformFn = sourceProj.getUnits() == Units$1.TILE_PIXELS ? function(inCoordinates, outCoordinates, stride) {
              var pixelExtent = sourceProj.getExtent();
              var projectedExtent = sourceProj.getWorldExtent();
              var scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
              compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale2, -scale2, 0, 0, 0);
              transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
              return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
            } : getTransform(sourceProj, destination);
            this.applyTransform(transformFn);
            return this;
          };
          return Geometry2;
        }(BaseObject$1)
      );
      var Geometry$1 = Geometry;
      var GeometryLayout = {
        XY: "XY",
        XYZ: "XYZ",
        XYM: "XYM",
        XYZM: "XYZM"
      };
      var __extends$d = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var SimpleGeometry = (
        /** @class */
        function(_super) {
          __extends$d(SimpleGeometry2, _super);
          function SimpleGeometry2() {
            var _this = _super.call(this) || this;
            _this.layout = GeometryLayout.XY;
            _this.stride = 2;
            _this.flatCoordinates = null;
            return _this;
          }
          SimpleGeometry2.prototype.computeExtent = function(extent) {
            return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
          };
          SimpleGeometry2.prototype.getCoordinates = function() {
            return abstract();
          };
          SimpleGeometry2.prototype.getFirstCoordinate = function() {
            return this.flatCoordinates.slice(0, this.stride);
          };
          SimpleGeometry2.prototype.getFlatCoordinates = function() {
            return this.flatCoordinates;
          };
          SimpleGeometry2.prototype.getLastCoordinate = function() {
            return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
          };
          SimpleGeometry2.prototype.getLayout = function() {
            return this.layout;
          };
          SimpleGeometry2.prototype.getSimplifiedGeometry = function(squaredTolerance) {
            if (this.simplifiedGeometryRevision !== this.getRevision()) {
              this.simplifiedGeometryMaxMinSquaredTolerance = 0;
              this.simplifiedGeometryRevision = this.getRevision();
            }
            if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
              return this;
            }
            var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
            var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
            if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
              return simplifiedGeometry;
            } else {
              this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
              return this;
            }
          };
          SimpleGeometry2.prototype.getSimplifiedGeometryInternal = function(squaredTolerance) {
            return this;
          };
          SimpleGeometry2.prototype.getStride = function() {
            return this.stride;
          };
          SimpleGeometry2.prototype.setFlatCoordinates = function(layout, flatCoordinates) {
            this.stride = getStrideForLayout(layout);
            this.layout = layout;
            this.flatCoordinates = flatCoordinates;
          };
          SimpleGeometry2.prototype.setCoordinates = function(coordinates, opt_layout) {
            abstract();
          };
          SimpleGeometry2.prototype.setLayout = function(layout, coordinates, nesting) {
            var stride;
            if (layout) {
              stride = getStrideForLayout(layout);
            } else {
              for (var i = 0; i < nesting; ++i) {
                if (coordinates.length === 0) {
                  this.layout = GeometryLayout.XY;
                  this.stride = 2;
                  return;
                } else {
                  coordinates = /** @type {Array} */
                  coordinates[0];
                }
              }
              stride = coordinates.length;
              layout = getLayoutForStride(stride);
            }
            this.layout = layout;
            this.stride = stride;
          };
          SimpleGeometry2.prototype.applyTransform = function(transformFn) {
            if (this.flatCoordinates) {
              transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
              this.changed();
            }
          };
          SimpleGeometry2.prototype.rotate = function(angle, anchor) {
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
              var stride = this.getStride();
              rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
              this.changed();
            }
          };
          SimpleGeometry2.prototype.scale = function(sx, opt_sy, opt_anchor) {
            var sy = opt_sy;
            if (sy === void 0) {
              sy = sx;
            }
            var anchor = opt_anchor;
            if (!anchor) {
              anchor = getCenter(this.getExtent());
            }
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
              var stride = this.getStride();
              scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
              this.changed();
            }
          };
          SimpleGeometry2.prototype.translate = function(deltaX, deltaY) {
            var flatCoordinates = this.getFlatCoordinates();
            if (flatCoordinates) {
              var stride = this.getStride();
              translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
              this.changed();
            }
          };
          return SimpleGeometry2;
        }(Geometry$1)
      );
      function getLayoutForStride(stride) {
        var layout;
        if (stride == 2) {
          layout = GeometryLayout.XY;
        } else if (stride == 3) {
          layout = GeometryLayout.XYZ;
        } else if (stride == 4) {
          layout = GeometryLayout.XYZM;
        }
        return (
          /** @type {import("./GeometryLayout.js").default} */
          layout
        );
      }
      function getStrideForLayout(layout) {
        var stride;
        if (layout == GeometryLayout.XY) {
          stride = 2;
        } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
          stride = 3;
        } else if (layout == GeometryLayout.XYZM) {
          stride = 4;
        }
        return (
          /** @type {number} */
          stride
        );
      }
      function transformGeom2D(simpleGeometry, transform2, opt_dest) {
        var flatCoordinates = simpleGeometry.getFlatCoordinates();
        if (!flatCoordinates) {
          return null;
        } else {
          var stride = simpleGeometry.getStride();
          return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform2, opt_dest);
        }
      }
      var SimpleGeometry$1 = SimpleGeometry;
      var __extends$c = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var CanvasImmediateRenderer = (
        /** @class */
        function(_super) {
          __extends$c(CanvasImmediateRenderer2, _super);
          function CanvasImmediateRenderer2(context, pixelRatio, extent, transform2, viewRotation, opt_squaredTolerance, opt_userTransform) {
            var _this = _super.call(this) || this;
            _this.context_ = context;
            _this.pixelRatio_ = pixelRatio;
            _this.extent_ = extent;
            _this.transform_ = transform2;
            _this.viewRotation_ = viewRotation;
            _this.squaredTolerance_ = opt_squaredTolerance;
            _this.userTransform_ = opt_userTransform;
            _this.contextFillState_ = null;
            _this.contextStrokeState_ = null;
            _this.contextTextState_ = null;
            _this.fillState_ = null;
            _this.strokeState_ = null;
            _this.image_ = null;
            _this.imageAnchorX_ = 0;
            _this.imageAnchorY_ = 0;
            _this.imageHeight_ = 0;
            _this.imageOpacity_ = 0;
            _this.imageOriginX_ = 0;
            _this.imageOriginY_ = 0;
            _this.imageRotateWithView_ = false;
            _this.imageRotation_ = 0;
            _this.imageScale_ = [0, 0];
            _this.imageWidth_ = 0;
            _this.text_ = "";
            _this.textOffsetX_ = 0;
            _this.textOffsetY_ = 0;
            _this.textRotateWithView_ = false;
            _this.textRotation_ = 0;
            _this.textScale_ = [0, 0];
            _this.textFillState_ = null;
            _this.textStrokeState_ = null;
            _this.textState_ = null;
            _this.pixelCoordinates_ = [];
            _this.tmpLocalTransform_ = create();
            return _this;
          }
          CanvasImmediateRenderer2.prototype.drawImages_ = function(flatCoordinates, offset, end, stride) {
            if (!this.image_) {
              return;
            }
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            var context = this.context_;
            var localTransform = this.tmpLocalTransform_;
            var alpha = context.globalAlpha;
            if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha * this.imageOpacity_;
            }
            var rotation = this.imageRotation_;
            if (this.imageRotateWithView_) {
              rotation += this.viewRotation_;
            }
            for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
              var x = pixelCoordinates[i] - this.imageAnchorX_;
              var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
              if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                var centerX = x + this.imageAnchorX_;
                var centerY = y + this.imageAnchorY_;
                compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                context.setTransform.apply(context, localTransform);
                context.translate(centerX, centerY);
                context.scale(this.imageScale_[0], this.imageScale_[1]);
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                context.setTransform(1, 0, 0, 1, 0, 0);
              } else {
                context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
              }
            }
            if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha;
            }
          };
          CanvasImmediateRenderer2.prototype.drawText_ = function(flatCoordinates, offset, end, stride) {
            if (!this.textState_ || this.text_ === "") {
              return;
            }
            if (this.textFillState_) {
              this.setContextFillState_(this.textFillState_);
            }
            if (this.textStrokeState_) {
              this.setContextStrokeState_(this.textStrokeState_);
            }
            this.setContextTextState_(this.textState_);
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            var context = this.context_;
            var rotation = this.textRotation_;
            if (this.textRotateWithView_) {
              rotation += this.viewRotation_;
            }
            for (; offset < end; offset += stride) {
              var x = pixelCoordinates[offset] + this.textOffsetX_;
              var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
              if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
                var localTransform = compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                context.setTransform.apply(context, localTransform);
                context.translate(x, y);
                context.scale(this.textScale_[0], this.textScale_[1]);
                if (this.textStrokeState_) {
                  context.strokeText(this.text_, 0, 0);
                }
                if (this.textFillState_) {
                  context.fillText(this.text_, 0, 0);
                }
                context.setTransform(1, 0, 0, 1, 0, 0);
              } else {
                if (this.textStrokeState_) {
                  context.strokeText(this.text_, x, y);
                }
                if (this.textFillState_) {
                  context.fillText(this.text_, x, y);
                }
              }
            }
          };
          CanvasImmediateRenderer2.prototype.moveToLineTo_ = function(flatCoordinates, offset, end, stride, close) {
            var context = this.context_;
            var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
            context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
            var length = pixelCoordinates.length;
            if (close) {
              length -= 2;
            }
            for (var i = 2; i < length; i += 2) {
              context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
            }
            if (close) {
              context.closePath();
            }
            return end;
          };
          CanvasImmediateRenderer2.prototype.drawRings_ = function(flatCoordinates, offset, ends, stride) {
            for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
            }
            return offset;
          };
          CanvasImmediateRenderer2.prototype.drawCircle = function(geometry) {
            if (!intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.fillState_ || this.strokeState_) {
              if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
              }
              var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
              var dx = pixelCoordinates[2] - pixelCoordinates[0];
              var dy = pixelCoordinates[3] - pixelCoordinates[1];
              var radius = Math.sqrt(dx * dx + dy * dy);
              var context = this.context_;
              context.beginPath();
              context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
              if (this.fillState_) {
                context.fill();
              }
              if (this.strokeState_) {
                context.stroke();
              }
            }
            if (this.text_ !== "") {
              this.drawText_(geometry.getCenter(), 0, 2, 2);
            }
          };
          CanvasImmediateRenderer2.prototype.setStyle = function(style) {
            this.setFillStrokeStyle(style.getFill(), style.getStroke());
            this.setImageStyle(style.getImage());
            this.setTextStyle(style.getText());
          };
          CanvasImmediateRenderer2.prototype.setTransform = function(transform2) {
            this.transform_ = transform2;
          };
          CanvasImmediateRenderer2.prototype.drawGeometry = function(geometry) {
            var type = geometry.getType();
            switch (type) {
              case GeometryType.POINT:
                this.drawPoint(
                  /** @type {import("../../geom/Point.js").default} */
                  geometry
                );
                break;
              case GeometryType.LINE_STRING:
                this.drawLineString(
                  /** @type {import("../../geom/LineString.js").default} */
                  geometry
                );
                break;
              case GeometryType.POLYGON:
                this.drawPolygon(
                  /** @type {import("../../geom/Polygon.js").default} */
                  geometry
                );
                break;
              case GeometryType.MULTI_POINT:
                this.drawMultiPoint(
                  /** @type {import("../../geom/MultiPoint.js").default} */
                  geometry
                );
                break;
              case GeometryType.MULTI_LINE_STRING:
                this.drawMultiLineString(
                  /** @type {import("../../geom/MultiLineString.js").default} */
                  geometry
                );
                break;
              case GeometryType.MULTI_POLYGON:
                this.drawMultiPolygon(
                  /** @type {import("../../geom/MultiPolygon.js").default} */
                  geometry
                );
                break;
              case GeometryType.GEOMETRY_COLLECTION:
                this.drawGeometryCollection(
                  /** @type {import("../../geom/GeometryCollection.js").default} */
                  geometry
                );
                break;
              case GeometryType.CIRCLE:
                this.drawCircle(
                  /** @type {import("../../geom/Circle.js").default} */
                  geometry
                );
                break;
            }
          };
          CanvasImmediateRenderer2.prototype.drawFeature = function(feature, style) {
            var geometry = style.getGeometryFunction()(feature);
            if (!geometry || !intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            this.setStyle(style);
            this.drawGeometry(geometry);
          };
          CanvasImmediateRenderer2.prototype.drawGeometryCollection = function(geometry) {
            var geometries = geometry.getGeometriesArray();
            for (var i = 0, ii = geometries.length; i < ii; ++i) {
              this.drawGeometry(geometries[i]);
            }
          };
          CanvasImmediateRenderer2.prototype.drawPoint = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Point.js").default} */
              geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            var flatCoordinates = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
            if (this.text_ !== "") {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
          };
          CanvasImmediateRenderer2.prototype.drawMultiPoint = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPoint.js").default} */
              geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            var flatCoordinates = geometry.getFlatCoordinates();
            var stride = geometry.getStride();
            if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
            if (this.text_ !== "") {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
            }
          };
          CanvasImmediateRenderer2.prototype.drawLineString = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/LineString.js").default} */
              geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            if (!intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              context.beginPath();
              this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
              context.stroke();
            }
            if (this.text_ !== "") {
              var flatMidpoint = geometry.getFlatMidpoint();
              this.drawText_(flatMidpoint, 0, 2, 2);
            }
          };
          CanvasImmediateRenderer2.prototype.drawMultiLineString = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiLineString.js").default} */
              geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            var geometryExtent = geometry.getExtent();
            if (!intersects(this.extent_, geometryExtent)) {
              return;
            }
            if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              var offset = 0;
              var ends = (
                /** @type {Array<number>} */
                geometry.getEnds()
              );
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
              }
              context.stroke();
            }
            if (this.text_ !== "") {
              var flatMidpoints = geometry.getFlatMidpoints();
              this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
            }
          };
          CanvasImmediateRenderer2.prototype.drawPolygon = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Polygon.js").default} */
              geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            if (!intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              context.beginPath();
              this.drawRings_(
                geometry.getOrientedFlatCoordinates(),
                0,
                /** @type {Array<number>} */
                geometry.getEnds(),
                geometry.getStride()
              );
              if (this.fillState_) {
                context.fill();
              }
              if (this.strokeState_) {
                context.stroke();
              }
            }
            if (this.text_ !== "") {
              var flatInteriorPoint = geometry.getFlatInteriorPoint();
              this.drawText_(flatInteriorPoint, 0, 2, 2);
            }
          };
          CanvasImmediateRenderer2.prototype.drawMultiPolygon = function(geometry) {
            if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_);
            }
            if (!intersects(this.extent_, geometry.getExtent())) {
              return;
            }
            if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              var flatCoordinates = geometry.getOrientedFlatCoordinates();
              var offset = 0;
              var endss = geometry.getEndss();
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                var ends = endss[i];
                offset = this.drawRings_(flatCoordinates, offset, ends, stride);
              }
              if (this.fillState_) {
                context.fill();
              }
              if (this.strokeState_) {
                context.stroke();
              }
            }
            if (this.text_ !== "") {
              var flatInteriorPoints = geometry.getFlatInteriorPoints();
              this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
            }
          };
          CanvasImmediateRenderer2.prototype.setContextFillState_ = function(fillState) {
            var context = this.context_;
            var contextFillState = this.contextFillState_;
            if (!contextFillState) {
              context.fillStyle = fillState.fillStyle;
              this.contextFillState_ = {
                fillStyle: fillState.fillStyle
              };
            } else {
              if (contextFillState.fillStyle != fillState.fillStyle) {
                contextFillState.fillStyle = fillState.fillStyle;
                context.fillStyle = fillState.fillStyle;
              }
            }
          };
          CanvasImmediateRenderer2.prototype.setContextStrokeState_ = function(strokeState) {
            var context = this.context_;
            var contextStrokeState = this.contextStrokeState_;
            if (!contextStrokeState) {
              context.lineCap = strokeState.lineCap;
              if (context.setLineDash) {
                context.setLineDash(strokeState.lineDash);
                context.lineDashOffset = strokeState.lineDashOffset;
              }
              context.lineJoin = strokeState.lineJoin;
              context.lineWidth = strokeState.lineWidth;
              context.miterLimit = strokeState.miterLimit;
              context.strokeStyle = strokeState.strokeStyle;
              this.contextStrokeState_ = {
                lineCap: strokeState.lineCap,
                lineDash: strokeState.lineDash,
                lineDashOffset: strokeState.lineDashOffset,
                lineJoin: strokeState.lineJoin,
                lineWidth: strokeState.lineWidth,
                miterLimit: strokeState.miterLimit,
                strokeStyle: strokeState.strokeStyle
              };
            } else {
              if (contextStrokeState.lineCap != strokeState.lineCap) {
                contextStrokeState.lineCap = strokeState.lineCap;
                context.lineCap = strokeState.lineCap;
              }
              if (context.setLineDash) {
                if (!equals$1(contextStrokeState.lineDash, strokeState.lineDash)) {
                  context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
                }
                if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                  contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                  context.lineDashOffset = strokeState.lineDashOffset;
                }
              }
              if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                contextStrokeState.lineJoin = strokeState.lineJoin;
                context.lineJoin = strokeState.lineJoin;
              }
              if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                contextStrokeState.lineWidth = strokeState.lineWidth;
                context.lineWidth = strokeState.lineWidth;
              }
              if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                contextStrokeState.miterLimit = strokeState.miterLimit;
                context.miterLimit = strokeState.miterLimit;
              }
              if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                contextStrokeState.strokeStyle = strokeState.strokeStyle;
                context.strokeStyle = strokeState.strokeStyle;
              }
            }
          };
          CanvasImmediateRenderer2.prototype.setContextTextState_ = function(textState) {
            var context = this.context_;
            var contextTextState = this.contextTextState_;
            var textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
            if (!contextTextState) {
              context.font = textState.font;
              context.textAlign = /** @type {CanvasTextAlign} */
              textAlign;
              context.textBaseline = /** @type {CanvasTextBaseline} */
              textState.textBaseline;
              this.contextTextState_ = {
                font: textState.font,
                textAlign,
                textBaseline: textState.textBaseline
              };
            } else {
              if (contextTextState.font != textState.font) {
                contextTextState.font = textState.font;
                context.font = textState.font;
              }
              if (contextTextState.textAlign != textAlign) {
                contextTextState.textAlign = /** @type {CanvasTextAlign} */
                textAlign;
                context.textAlign = /** @type {CanvasTextAlign} */
                textAlign;
              }
              if (contextTextState.textBaseline != textState.textBaseline) {
                contextTextState.textBaseline = /** @type {CanvasTextBaseline} */
                textState.textBaseline;
                context.textBaseline = /** @type {CanvasTextBaseline} */
                textState.textBaseline;
              }
            }
          };
          CanvasImmediateRenderer2.prototype.setFillStrokeStyle = function(fillStyle, strokeStyle) {
            var _this = this;
            if (!fillStyle) {
              this.fillState_ = null;
            } else {
              var fillStyleColor = fillStyle.getColor();
              this.fillState_ = {
                fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle)
              };
            }
            if (!strokeStyle) {
              this.strokeState_ = null;
            } else {
              var strokeStyleColor = strokeStyle.getColor();
              var strokeStyleLineCap = strokeStyle.getLineCap();
              var strokeStyleLineDash = strokeStyle.getLineDash();
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              var strokeStyleWidth = strokeStyle.getWidth();
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              var lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
              this.strokeState_ = {
                lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
                lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map(function(n) {
                  return n * _this.pixelRatio_;
                }),
                lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
                lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
                lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
                miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
                strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle)
              };
            }
          };
          CanvasImmediateRenderer2.prototype.setImageStyle = function(imageStyle) {
            var imageSize;
            if (!imageStyle || !(imageSize = imageStyle.getSize())) {
              this.image_ = null;
              return;
            }
            var imageAnchor = imageStyle.getAnchor();
            var imageOrigin = imageStyle.getOrigin();
            this.image_ = imageStyle.getImage(this.pixelRatio_);
            this.imageAnchorX_ = imageAnchor[0] * this.pixelRatio_;
            this.imageAnchorY_ = imageAnchor[1] * this.pixelRatio_;
            this.imageHeight_ = imageSize[1] * this.pixelRatio_;
            this.imageOpacity_ = imageStyle.getOpacity();
            this.imageOriginX_ = imageOrigin[0];
            this.imageOriginY_ = imageOrigin[1];
            this.imageRotateWithView_ = imageStyle.getRotateWithView();
            this.imageRotation_ = imageStyle.getRotation();
            this.imageScale_ = imageStyle.getScaleArray();
            this.imageWidth_ = imageSize[0] * this.pixelRatio_;
          };
          CanvasImmediateRenderer2.prototype.setTextStyle = function(textStyle) {
            if (!textStyle) {
              this.text_ = "";
            } else {
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                this.textFillState_ = null;
              } else {
                var textFillStyleColor = textFillStyle.getColor();
                this.textFillState_ = {
                  fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle)
                };
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                this.textStrokeState_ = null;
              } else {
                var textStrokeStyleColor = textStrokeStyle.getColor();
                var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                var textStrokeStyleWidth = textStrokeStyle.getWidth();
                var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                this.textStrokeState_ = {
                  lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
                  lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
                  lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
                  lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
                  lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
                  miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
                  strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle)
                };
              }
              var textFont = textStyle.getFont();
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              var textScale = textStyle.getScaleArray();
              var textText = textStyle.getText();
              var textTextAlign = textStyle.getTextAlign();
              var textTextBaseline = textStyle.getTextBaseline();
              this.textState_ = {
                font: textFont !== void 0 ? textFont : defaultFont,
                textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
                textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
              };
              this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce(function(acc, t, i) {
                return acc += i % 2 ? " " : t;
              }, "") : textText : "";
              this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
              this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
              this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
              this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
              this.textScale_ = [
                this.pixelRatio_ * textScale[0],
                this.pixelRatio_ * textScale[1]
              ];
            }
          };
          return CanvasImmediateRenderer2;
        }(VectorContext$1)
      );
      var CanvasImmediateRenderer$1 = CanvasImmediateRenderer;
      var IconAnchorUnits = {
        /**
         * Anchor is a fraction
         * @api
         */
        FRACTION: "fraction",
        /**
         * Anchor is in pixels
         * @api
         */
        PIXELS: "pixels"
      };
      var IconOrigin = {
        /**
         * Origin is at bottom left
         * @api
         */
        BOTTOM_LEFT: "bottom-left",
        /**
         * Origin is at bottom right
         * @api
         */
        BOTTOM_RIGHT: "bottom-right",
        /**
         * Origin is at top left
         * @api
         */
        TOP_LEFT: "top-left",
        /**
         * Origin is at top right
         * @api
         */
        TOP_RIGHT: "top-right"
      };
      var IconImageCache = (
        /** @class */
        function() {
          function IconImageCache2() {
            this.cache_ = {};
            this.cacheSize_ = 0;
            this.maxCacheSize_ = 32;
          }
          IconImageCache2.prototype.clear = function() {
            this.cache_ = {};
            this.cacheSize_ = 0;
          };
          IconImageCache2.prototype.canExpireCache = function() {
            return this.cacheSize_ > this.maxCacheSize_;
          };
          IconImageCache2.prototype.expire = function() {
            if (this.canExpireCache()) {
              var i = 0;
              for (var key in this.cache_) {
                var iconImage = this.cache_[key];
                if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                  delete this.cache_[key];
                  --this.cacheSize_;
                }
              }
            }
          };
          IconImageCache2.prototype.get = function(src, crossOrigin, color) {
            var key = getKey(src, crossOrigin, color);
            return key in this.cache_ ? this.cache_[key] : null;
          };
          IconImageCache2.prototype.set = function(src, crossOrigin, color, iconImage) {
            var key = getKey(src, crossOrigin, color);
            this.cache_[key] = iconImage;
            ++this.cacheSize_;
          };
          IconImageCache2.prototype.setSize = function(maxCacheSize) {
            this.maxCacheSize_ = maxCacheSize;
            this.expire();
          };
          return IconImageCache2;
        }()
      );
      function getKey(src, crossOrigin, color) {
        var colorString = color ? asString(color) : "null";
        return crossOrigin + ":" + src + ":" + colorString;
      }
      var shared = new IconImageCache();
      var __extends$b = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var ImageBase = (
        /** @class */
        function(_super) {
          __extends$b(ImageBase2, _super);
          function ImageBase2(extent, resolution, pixelRatio, state) {
            var _this = _super.call(this) || this;
            _this.extent = extent;
            _this.pixelRatio_ = pixelRatio;
            _this.resolution = resolution;
            _this.state = state;
            return _this;
          }
          ImageBase2.prototype.changed = function() {
            this.dispatchEvent(EventType.CHANGE);
          };
          ImageBase2.prototype.getExtent = function() {
            return this.extent;
          };
          ImageBase2.prototype.getImage = function() {
            return abstract();
          };
          ImageBase2.prototype.getPixelRatio = function() {
            return this.pixelRatio_;
          };
          ImageBase2.prototype.getResolution = function() {
            return (
              /** @type {number} */
              this.resolution
            );
          };
          ImageBase2.prototype.getState = function() {
            return this.state;
          };
          ImageBase2.prototype.load = function() {
            abstract();
          };
          return ImageBase2;
        }(EventTarget)
      );
      var ImageBase$1 = ImageBase;
      var __extends$a = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      (function(_super) {
        __extends$a(ImageWrapper, _super);
        function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
          var _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE) || this;
          _this.src_ = src;
          _this.image_ = new Image();
          if (crossOrigin !== null) {
            _this.image_.crossOrigin = crossOrigin;
          }
          _this.unlisten_ = null;
          _this.state = ImageState.IDLE;
          _this.imageLoadFunction_ = imageLoadFunction;
          return _this;
        }
        ImageWrapper.prototype.getImage = function() {
          return this.image_;
        };
        ImageWrapper.prototype.handleImageError_ = function() {
          this.state = ImageState.ERROR;
          this.unlistenImage_();
          this.changed();
        };
        ImageWrapper.prototype.handleImageLoad_ = function() {
          if (this.resolution === void 0) {
            this.resolution = getHeight(this.extent) / this.image_.height;
          }
          this.state = ImageState.LOADED;
          this.unlistenImage_();
          this.changed();
        };
        ImageWrapper.prototype.load = function() {
          if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
            this.state = ImageState.LOADING;
            this.changed();
            this.imageLoadFunction_(this, this.src_);
            this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
        };
        ImageWrapper.prototype.setImage = function(image) {
          this.image_ = image;
          this.resolution = getHeight(this.extent) / this.image_.height;
        };
        ImageWrapper.prototype.unlistenImage_ = function() {
          if (this.unlisten_) {
            this.unlisten_();
            this.unlisten_ = null;
          }
        };
        return ImageWrapper;
      })(ImageBase$1);
      function listenImage(image, loadHandler, errorHandler) {
        var img = (
          /** @type {HTMLImageElement} */
          image
        );
        var listening = true;
        var decoding = false;
        var loaded = false;
        var listenerKeys = [
          listenOnce(img, EventType.LOAD, function() {
            loaded = true;
            if (!decoding) {
              loadHandler();
            }
          })
        ];
        if (img.src && IMAGE_DECODE) {
          decoding = true;
          img.decode().then(function() {
            if (listening) {
              loadHandler();
            }
          }).catch(function(error) {
            if (listening) {
              if (loaded) {
                loadHandler();
              } else {
                errorHandler();
              }
            }
          });
        } else {
          listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));
        }
        return function unlisten() {
          listening = false;
          listenerKeys.forEach(unlistenByKey);
        };
      }
      var __extends$9 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var taintedTestContext = null;
      var IconImage = (
        /** @class */
        function(_super) {
          __extends$9(IconImage2, _super);
          function IconImage2(image, src, size, crossOrigin, imageState, color) {
            var _this = _super.call(this) || this;
            _this.hitDetectionImage_ = null;
            _this.image_ = !image ? new Image() : image;
            if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
            }
            _this.canvas_ = {};
            _this.color_ = color;
            _this.unlisten_ = null;
            _this.imageState_ = imageState;
            _this.size_ = size;
            _this.src_ = src;
            _this.tainted_;
            return _this;
          }
          IconImage2.prototype.isTainted_ = function() {
            if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
              if (!taintedTestContext) {
                taintedTestContext = createCanvasContext2D(1, 1);
              }
              taintedTestContext.drawImage(this.image_, 0, 0);
              try {
                taintedTestContext.getImageData(0, 0, 1, 1);
                this.tainted_ = false;
              } catch (e) {
                taintedTestContext = null;
                this.tainted_ = true;
              }
            }
            return this.tainted_ === true;
          };
          IconImage2.prototype.dispatchChangeEvent_ = function() {
            this.dispatchEvent(EventType.CHANGE);
          };
          IconImage2.prototype.handleImageError_ = function() {
            this.imageState_ = ImageState.ERROR;
            this.unlistenImage_();
            this.dispatchChangeEvent_();
          };
          IconImage2.prototype.handleImageLoad_ = function() {
            this.imageState_ = ImageState.LOADED;
            if (this.size_) {
              this.image_.width = this.size_[0];
              this.image_.height = this.size_[1];
            } else {
              this.size_ = [this.image_.width, this.image_.height];
            }
            this.unlistenImage_();
            this.dispatchChangeEvent_();
          };
          IconImage2.prototype.getImage = function(pixelRatio) {
            this.replaceColor_(pixelRatio);
            return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
          };
          IconImage2.prototype.getPixelRatio = function(pixelRatio) {
            this.replaceColor_(pixelRatio);
            return this.canvas_[pixelRatio] ? pixelRatio : 1;
          };
          IconImage2.prototype.getImageState = function() {
            return this.imageState_;
          };
          IconImage2.prototype.getHitDetectionImage = function() {
            if (!this.hitDetectionImage_) {
              if (this.isTainted_()) {
                var width = this.size_[0];
                var height = this.size_[1];
                var context = createCanvasContext2D(width, height);
                context.fillRect(0, 0, width, height);
                this.hitDetectionImage_ = context.canvas;
              } else {
                this.hitDetectionImage_ = this.image_;
              }
            }
            return this.hitDetectionImage_;
          };
          IconImage2.prototype.getSize = function() {
            return this.size_;
          };
          IconImage2.prototype.getSrc = function() {
            return this.src_;
          };
          IconImage2.prototype.load = function() {
            if (this.imageState_ == ImageState.IDLE) {
              this.imageState_ = ImageState.LOADING;
              try {
                this.image_.src = this.src_;
              } catch (e) {
                this.handleImageError_();
              }
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
            }
          };
          IconImage2.prototype.replaceColor_ = function(pixelRatio) {
            if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {
              return;
            }
            var canvas = document.createElement("canvas");
            this.canvas_[pixelRatio] = canvas;
            canvas.width = Math.ceil(this.image_.width * pixelRatio);
            canvas.height = Math.ceil(this.image_.height * pixelRatio);
            var ctx = canvas.getContext("2d");
            ctx.scale(pixelRatio, pixelRatio);
            ctx.drawImage(this.image_, 0, 0);
            ctx.globalCompositeOperation = "multiply";
            if (ctx.globalCompositeOperation === "multiply" || this.isTainted_()) {
              ctx.fillStyle = asString(this.color_);
              ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
              ctx.globalCompositeOperation = "destination-in";
              ctx.drawImage(this.image_, 0, 0);
            } else {
              var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              var data = imgData.data;
              var r = this.color_[0] / 255;
              var g = this.color_[1] / 255;
              var b = this.color_[2] / 255;
              var a = this.color_[3];
              for (var i = 0, ii = data.length; i < ii; i += 4) {
                data[i] *= r;
                data[i + 1] *= g;
                data[i + 2] *= b;
                data[i + 3] *= a;
              }
              ctx.putImageData(imgData, 0, 0);
            }
          };
          IconImage2.prototype.unlistenImage_ = function() {
            if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
            }
          };
          return IconImage2;
        }(EventTarget)
      );
      function get(image, src, size, crossOrigin, imageState, color) {
        var iconImage = shared.get(src, crossOrigin, color);
        if (!iconImage) {
          iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
          shared.set(src, crossOrigin, color, iconImage);
        }
        return iconImage;
      }
      var __extends$8 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Icon = (
        /** @class */
        function(_super) {
          __extends$8(Icon2, _super);
          function Icon2(opt_options) {
            var _this = this;
            var options = opt_options || {};
            var opacity = options.opacity !== void 0 ? options.opacity : 1;
            var rotation = options.rotation !== void 0 ? options.rotation : 0;
            var scale2 = options.scale !== void 0 ? options.scale : 1;
            var rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
            _this = _super.call(this, {
              opacity,
              rotation,
              scale: scale2,
              displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
              rotateWithView
            }) || this;
            _this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
            _this.normalizedAnchor_ = null;
            _this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : IconOrigin.TOP_LEFT;
            _this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : IconAnchorUnits.FRACTION;
            _this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : IconAnchorUnits.FRACTION;
            _this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
            var image = options.img !== void 0 ? options.img : null;
            _this.imgSize_ = options.imgSize;
            var src = options.src;
            assert(!(src !== void 0 && image), 4);
            assert(!image || image && _this.imgSize_, 5);
            if ((src === void 0 || src.length === 0) && image) {
              src = /** @type {HTMLImageElement} */
              image.src || getUid(image);
            }
            assert(src !== void 0 && src.length > 0, 6);
            var imageState = options.src !== void 0 ? ImageState.IDLE : ImageState.LOADED;
            _this.color_ = options.color !== void 0 ? asArray(options.color) : null;
            _this.iconImage_ = get(
              image,
              /** @type {string} */
              src,
              _this.imgSize_ !== void 0 ? _this.imgSize_ : null,
              _this.crossOrigin_,
              imageState,
              _this.color_
            );
            _this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
            _this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : IconOrigin.TOP_LEFT;
            _this.origin_ = null;
            _this.size_ = options.size !== void 0 ? options.size : null;
            return _this;
          }
          Icon2.prototype.clone = function() {
            var scale2 = this.getScale();
            return new Icon2({
              anchor: this.anchor_.slice(),
              anchorOrigin: this.anchorOrigin_,
              anchorXUnits: this.anchorXUnits_,
              anchorYUnits: this.anchorYUnits_,
              color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
              crossOrigin: this.crossOrigin_,
              imgSize: this.imgSize_,
              offset: this.offset_.slice(),
              offsetOrigin: this.offsetOrigin_,
              opacity: this.getOpacity(),
              rotateWithView: this.getRotateWithView(),
              rotation: this.getRotation(),
              scale: Array.isArray(scale2) ? scale2.slice() : scale2,
              size: this.size_ !== null ? this.size_.slice() : void 0,
              src: this.getSrc()
            });
          };
          Icon2.prototype.getAnchor = function() {
            var anchor = this.normalizedAnchor_;
            if (!anchor) {
              anchor = this.anchor_;
              var size = this.getSize();
              if (this.anchorXUnits_ == IconAnchorUnits.FRACTION || this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                if (!size) {
                  return null;
                }
                anchor = this.anchor_.slice();
                if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[0] *= size[0];
                }
                if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[1] *= size[1];
                }
              }
              if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
                if (!size) {
                  return null;
                }
                if (anchor === this.anchor_) {
                  anchor = this.anchor_.slice();
                }
                if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[0] = -anchor[0] + size[0];
                }
                if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT || this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[1] = -anchor[1] + size[1];
                }
              }
              this.normalizedAnchor_ = anchor;
            }
            var displacement = this.getDisplacement();
            return [anchor[0] - displacement[0], anchor[1] + displacement[1]];
          };
          Icon2.prototype.setAnchor = function(anchor) {
            this.anchor_ = anchor;
            this.normalizedAnchor_ = null;
          };
          Icon2.prototype.getColor = function() {
            return this.color_;
          };
          Icon2.prototype.getImage = function(pixelRatio) {
            return this.iconImage_.getImage(pixelRatio);
          };
          Icon2.prototype.getPixelRatio = function(pixelRatio) {
            return this.iconImage_.getPixelRatio(pixelRatio);
          };
          Icon2.prototype.getImageSize = function() {
            return this.iconImage_.getSize();
          };
          Icon2.prototype.getImageState = function() {
            return this.iconImage_.getImageState();
          };
          Icon2.prototype.getHitDetectionImage = function() {
            return this.iconImage_.getHitDetectionImage();
          };
          Icon2.prototype.getOrigin = function() {
            if (this.origin_) {
              return this.origin_;
            }
            var offset = this.offset_;
            if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
              var size = this.getSize();
              var iconImageSize = this.iconImage_.getSize();
              if (!size || !iconImageSize) {
                return null;
              }
              offset = offset.slice();
              if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                offset[0] = iconImageSize[0] - size[0] - offset[0];
              }
              if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT || this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                offset[1] = iconImageSize[1] - size[1] - offset[1];
              }
            }
            this.origin_ = offset;
            return this.origin_;
          };
          Icon2.prototype.getSrc = function() {
            return this.iconImage_.getSrc();
          };
          Icon2.prototype.getSize = function() {
            return !this.size_ ? this.iconImage_.getSize() : this.size_;
          };
          Icon2.prototype.listenImageChange = function(listener) {
            this.iconImage_.addEventListener(EventType.CHANGE, listener);
          };
          Icon2.prototype.load = function() {
            this.iconImage_.load();
          };
          Icon2.prototype.unlistenImageChange = function(listener) {
            this.iconImage_.removeEventListener(EventType.CHANGE, listener);
          };
          return Icon2;
        }(ImageStyle$1)
      );
      var Icon$1 = Icon;
      var HIT_DETECT_RESOLUTION = 0.5;
      function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation) {
        var width = size[0] * HIT_DETECT_RESOLUTION;
        var height = size[1] * HIT_DETECT_RESOLUTION;
        var context = createCanvasContext2D(width, height);
        context.imageSmoothingEnabled = false;
        var canvas = context.canvas;
        var renderer = new CanvasImmediateRenderer$1(context, HIT_DETECT_RESOLUTION, extent, null, rotation);
        var featureCount = features.length;
        var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
        var featuresByZIndex = {};
        for (var i = 1; i <= featureCount; ++i) {
          var feature = features[i - 1];
          var featureStyleFunction = feature.getStyleFunction() || styleFunction;
          if (!styleFunction) {
            continue;
          }
          var styles = featureStyleFunction(feature, resolution);
          if (!styles) {
            continue;
          }
          if (!Array.isArray(styles)) {
            styles = [styles];
          }
          var index = i * indexFactor;
          var color = "#" + ("000000" + index.toString(16)).slice(-6);
          for (var j = 0, jj = styles.length; j < jj; ++j) {
            var originalStyle = styles[j];
            var geometry = originalStyle.getGeometryFunction()(feature);
            if (!geometry || !intersects(extent, geometry.getExtent())) {
              continue;
            }
            var style = originalStyle.clone();
            var fill = style.getFill();
            if (fill) {
              fill.setColor(color);
            }
            var stroke = style.getStroke();
            if (stroke) {
              stroke.setColor(color);
              stroke.setLineDash(null);
            }
            style.setText(void 0);
            var image = originalStyle.getImage();
            if (image && image.getOpacity() !== 0) {
              var imgSize = image.getImageSize();
              if (!imgSize) {
                continue;
              }
              var imgContext = createCanvasContext2D(imgSize[0], imgSize[1], void 0, { alpha: false });
              var img = imgContext.canvas;
              imgContext.fillStyle = color;
              imgContext.fillRect(0, 0, img.width, img.height);
              style.setImage(new Icon$1({
                img,
                imgSize,
                anchor: image.getAnchor(),
                anchorXUnits: IconAnchorUnits.PIXELS,
                anchorYUnits: IconAnchorUnits.PIXELS,
                offset: image.getOrigin(),
                opacity: 1,
                size: image.getSize(),
                scale: image.getScale(),
                rotation: image.getRotation(),
                rotateWithView: image.getRotateWithView()
              }));
            }
            var zIndex = style.getZIndex() || 0;
            var byGeometryType = featuresByZIndex[zIndex];
            if (!byGeometryType) {
              byGeometryType = {};
              featuresByZIndex[zIndex] = byGeometryType;
              byGeometryType[GeometryType.POLYGON] = [];
              byGeometryType[GeometryType.CIRCLE] = [];
              byGeometryType[GeometryType.LINE_STRING] = [];
              byGeometryType[GeometryType.POINT] = [];
            }
            byGeometryType[geometry.getType().replace("Multi", "")].push(geometry, style);
          }
        }
        var zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(numberSafeCompareFunction);
        for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
          var byGeometryType = featuresByZIndex[zIndexKeys[i]];
          for (var type in byGeometryType) {
            var geomAndStyle = byGeometryType[type];
            for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
              renderer.setStyle(geomAndStyle[j + 1]);
              for (var k = 0, kk = transforms2.length; k < kk; ++k) {
                renderer.setTransform(transforms2[k]);
                renderer.drawGeometry(geomAndStyle[j]);
              }
            }
          }
        }
        return context.getImageData(0, 0, canvas.width, canvas.height);
      }
      function hitDetect(pixel, features, imageData) {
        var resultFeatures = [];
        if (imageData) {
          var x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
          var y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
          var index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
          var r = imageData.data[index];
          var g = imageData.data[index + 1];
          var b = imageData.data[index + 2];
          var i = b + 256 * (g + 256 * r);
          var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
          if (i && i % indexFactor === 0) {
            resultFeatures.push(features[i / indexFactor - 1]);
          }
        }
        return resultFeatures;
      }
      var SIMPLIFY_TOLERANCE = 0.5;
      var GEOMETRY_RENDERERS = {
        "Point": renderPointGeometry,
        "LineString": renderLineStringGeometry,
        "Polygon": renderPolygonGeometry,
        "MultiPoint": renderMultiPointGeometry,
        "MultiLineString": renderMultiLineStringGeometry,
        "MultiPolygon": renderMultiPolygonGeometry,
        "GeometryCollection": renderGeometryCollectionGeometry,
        "Circle": renderCircleGeometry
      };
      function defaultOrder(feature1, feature2) {
        return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
      }
      function getSquaredTolerance(resolution, pixelRatio) {
        var tolerance = getTolerance(resolution, pixelRatio);
        return tolerance * tolerance;
      }
      function getTolerance(resolution, pixelRatio) {
        return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
      }
      function renderCircleGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var fillStyle = style.getFill();
        var strokeStyle = style.getStroke();
        if (fillStyle || strokeStyle) {
          var circleReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.CIRCLE);
          circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          circleReplay.drawCircle(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
          var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle);
          textReplay.drawText(geometry, feature);
        }
      }
      function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform, opt_declutterBuilderGroup) {
        var loading = false;
        var imageStyle = style.getImage();
        if (imageStyle) {
          var imageState = imageStyle.getImageState();
          if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
            imageStyle.unlistenImageChange(listener);
          } else {
            if (imageState == ImageState.IDLE) {
              imageStyle.load();
            }
            imageState = imageStyle.getImageState();
            imageStyle.listenImageChange(listener);
            loading = true;
          }
        }
        renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup);
        return loading;
      }
      function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform, opt_declutterBuilderGroup) {
        var geometry = style.getGeometryFunction()(feature);
        if (!geometry) {
          return;
        }
        var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
        var renderer = style.getRenderer();
        if (renderer) {
          renderGeometry(replayGroup, simplifiedGeometry, style, feature);
        } else {
          var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
          geometryRenderer(replayGroup, simplifiedGeometry, style, feature, opt_declutterBuilderGroup);
        }
      }
      function renderGeometry(replayGroup, geometry, style, feature) {
        if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
          var geometries = (
            /** @type {import("../geom/GeometryCollection.js").default} */
            geometry.getGeometries()
          );
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
            renderGeometry(replayGroup, geometries[i], style, feature);
          }
          return;
        }
        var replay = replayGroup.getBuilder(style.getZIndex(), BuilderType.DEFAULT);
        replay.drawCustom(
          /** @type {import("../geom/SimpleGeometry.js").default} */
          geometry,
          feature,
          style.getRenderer(),
          style.getHitDetectionRenderer()
        );
      }
      function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var geometries = geometry.getGeometriesArray();
        var i, ii;
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
          geometryRenderer(replayGroup, geometries[i], style, feature, opt_declutterBuilderGroup);
        }
      }
      function renderLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var strokeStyle = style.getStroke();
        if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawLineString(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
          var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle);
          textReplay.drawText(geometry, feature);
        }
      }
      function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var strokeStyle = style.getStroke();
        if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawMultiLineString(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
          var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle);
          textReplay.drawText(geometry, feature);
        }
      }
      function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var fillStyle = style.getFill();
        var strokeStyle = style.getStroke();
        if (strokeStyle || fillStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawMultiPolygon(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
          var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle);
          textReplay.drawText(geometry, feature);
        }
      }
      function renderPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var imageStyle = style.getImage();
        var textStyle = style.getText();
        var declutterImageWithText;
        if (opt_declutterBuilderGroup) {
          builderGroup = opt_declutterBuilderGroup;
          declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
        }
        if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
            return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
          imageReplay.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay.drawPoint(geometry, feature);
        }
        if (textStyle && textStyle.getText()) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, declutterImageWithText);
          textReplay.drawText(geometry, feature);
        }
      }
      function renderMultiPointGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var imageStyle = style.getImage();
        var textStyle = style.getText();
        var declutterImageWithText;
        if (opt_declutterBuilderGroup) {
          builderGroup = opt_declutterBuilderGroup;
          declutterImageWithText = imageStyle && textStyle && textStyle.getText() ? {} : void 0;
        }
        if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
            return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.IMAGE);
          imageReplay.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay.drawMultiPoint(geometry, feature);
        }
        if (textStyle && textStyle.getText()) {
          var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle, declutterImageWithText);
          textReplay.drawText(geometry, feature);
        }
      }
      function renderPolygonGeometry(builderGroup, geometry, style, feature, opt_declutterBuilderGroup) {
        var fillStyle = style.getFill();
        var strokeStyle = style.getStroke();
        if (fillStyle || strokeStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), BuilderType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawPolygon(geometry, feature);
        }
        var textStyle = style.getText();
        if (textStyle && textStyle.getText()) {
          var textReplay = (opt_declutterBuilderGroup || builderGroup).getBuilder(style.getZIndex(), BuilderType.TEXT);
          textReplay.setTextStyle(textStyle);
          textReplay.drawText(geometry, feature);
        }
      }
      var __extends$7 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var CanvasVectorLayerRenderer = (
        /** @class */
        function(_super) {
          __extends$7(CanvasVectorLayerRenderer2, _super);
          function CanvasVectorLayerRenderer2(vectorLayer) {
            var _this = _super.call(this, vectorLayer) || this;
            _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
            _this.animatingOrInteracting_;
            _this.dirty_ = false;
            _this.hitDetectionImageData_ = null;
            _this.renderedFeatures_ = null;
            _this.renderedRevision_ = -1;
            _this.renderedResolution_ = NaN;
            _this.renderedExtent_ = createEmpty();
            _this.wrappedRenderedExtent_ = createEmpty();
            _this.renderedRotation_;
            _this.renderedCenter_ = null;
            _this.renderedProjection_ = null;
            _this.renderedRenderOrder_ = null;
            _this.replayGroup_ = null;
            _this.replayGroupChanged = true;
            _this.declutterExecutorGroup = null;
            _this.clipping = true;
            return _this;
          }
          CanvasVectorLayerRenderer2.prototype.renderWorlds = function(executorGroup, frameState, opt_declutterTree) {
            var extent = frameState.extent;
            var viewState = frameState.viewState;
            var center = viewState.center;
            var resolution = viewState.resolution;
            var projection = viewState.projection;
            var rotation = viewState.rotation;
            var projectionExtent = projection.getExtent();
            var vectorSource = this.getLayer().getSource();
            var pixelRatio = frameState.pixelRatio;
            var viewHints = frameState.viewHints;
            var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
            var context = this.context;
            var width = Math.round(frameState.size[0] * pixelRatio);
            var height = Math.round(frameState.size[1] * pixelRatio);
            var multiWorld = vectorSource.getWrapX() && projection.canWrapX();
            var worldWidth = multiWorld ? getWidth(projectionExtent) : null;
            var endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
            var world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
            do {
              var transform2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, world * worldWidth);
              executorGroup.execute(context, 1, transform2, rotation, snapToPixel, void 0, opt_declutterTree);
            } while (++world < endWorld);
          };
          CanvasVectorLayerRenderer2.prototype.renderDeclutter = function(frameState) {
            if (this.declutterExecutorGroup) {
              this.renderWorlds(this.declutterExecutorGroup, frameState, frameState.declutterTree);
            }
          };
          CanvasVectorLayerRenderer2.prototype.renderFrame = function(frameState, target) {
            var pixelRatio = frameState.pixelRatio;
            var layerState = frameState.layerStatesArray[frameState.layerIndex];
            makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
            makeInverse(this.inversePixelTransform, this.pixelTransform);
            var canvasTransform = toString(this.pixelTransform);
            this.useContainer(target, canvasTransform, layerState.opacity, this.getBackground(frameState));
            var context = this.context;
            var canvas = context.canvas;
            var replayGroup = this.replayGroup_;
            var declutterExecutorGroup = this.declutterExecutorGroup;
            if ((!replayGroup || replayGroup.isEmpty()) && (!declutterExecutorGroup || declutterExecutorGroup.isEmpty())) {
              return null;
            }
            var width = Math.round(frameState.size[0] * pixelRatio);
            var height = Math.round(frameState.size[1] * pixelRatio);
            if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
              if (canvas.style.transform !== canvasTransform) {
                canvas.style.transform = canvasTransform;
              }
            } else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
            }
            this.preRender(context, frameState);
            var viewState = frameState.viewState;
            viewState.projection;
            var clipped = false;
            var render = true;
            if (layerState.extent && this.clipping) {
              var layerExtent = fromUserExtent(layerState.extent);
              render = intersects(layerExtent, frameState.extent);
              clipped = render && !containsExtent(layerExtent, frameState.extent);
              if (clipped) {
                this.clipUnrotated(context, frameState, layerExtent);
              }
            }
            if (render) {
              this.renderWorlds(replayGroup, frameState);
            }
            if (clipped) {
              context.restore();
            }
            this.postRender(context, frameState);
            var opacity = cssOpacity(layerState.opacity);
            var container = this.container;
            if (opacity !== container.style.opacity) {
              container.style.opacity = opacity;
            }
            if (this.renderedRotation_ !== viewState.rotation) {
              this.renderedRotation_ = viewState.rotation;
              this.hitDetectionImageData_ = null;
            }
            return this.container;
          };
          CanvasVectorLayerRenderer2.prototype.getFeatures = function(pixel) {
            return new Promise(
              /**
               * @param {function(Array<import("../../Feature").default|import("../../render/Feature").default>): void} resolve Resolver function.
               * @this {CanvasVectorLayerRenderer}
               */
              (function(resolve) {
                if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                  var size = [this.context.canvas.width, this.context.canvas.height];
                  apply(this.pixelTransform, size);
                  var center = this.renderedCenter_;
                  var resolution = this.renderedResolution_;
                  var rotation = this.renderedRotation_;
                  var projection = this.renderedProjection_;
                  var extent = this.wrappedRenderedExtent_;
                  var layer = this.getLayer();
                  var transforms2 = [];
                  var width = size[0] * HIT_DETECT_RESOLUTION;
                  var height = size[1] * HIT_DETECT_RESOLUTION;
                  transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, 0).slice());
                  var source = layer.getSource();
                  var projectionExtent = projection.getExtent();
                  if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
                    var startX = extent[0];
                    var worldWidth = getWidth(projectionExtent);
                    var world = 0;
                    var offsetX = void 0;
                    while (startX < projectionExtent[0]) {
                      --world;
                      offsetX = worldWidth * world;
                      transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                      startX += worldWidth;
                    }
                    world = 0;
                    startX = extent[2];
                    while (startX > projectionExtent[2]) {
                      ++world;
                      offsetX = worldWidth * world;
                      transforms2.push(this.getRenderTransform(center, resolution, rotation, HIT_DETECT_RESOLUTION, width, height, offsetX).slice());
                      startX -= worldWidth;
                    }
                  }
                  this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms2, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
                }
                resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
              }).bind(this)
            );
          };
          CanvasVectorLayerRenderer2.prototype.forEachFeatureAtCoordinate = function(coordinate, frameState, hitTolerance, callback, matches) {
            var _this = this;
            if (!this.replayGroup_) {
              return void 0;
            }
            var resolution = frameState.viewState.resolution;
            var rotation = frameState.viewState.rotation;
            var layer = this.getLayer();
            var features = {};
            var featureCallback = function(feature, geometry, distanceSq) {
              var key = getUid(feature);
              var match = features[key];
              if (!match) {
                if (distanceSq === 0) {
                  features[key] = true;
                  return callback(feature, layer, geometry);
                }
                matches.push(features[key] = {
                  feature,
                  layer,
                  geometry,
                  distanceSq,
                  callback
                });
              } else if (match !== true && distanceSq < match.distanceSq) {
                if (distanceSq === 0) {
                  features[key] = true;
                  matches.splice(matches.lastIndexOf(match), 1);
                  return callback(feature, layer, geometry);
                }
                match.geometry = geometry;
                match.distanceSq = distanceSq;
              }
              return void 0;
            };
            var result;
            var executorGroups = [this.replayGroup_];
            if (this.declutterExecutorGroup) {
              executorGroups.push(this.declutterExecutorGroup);
            }
            executorGroups.some(function(executorGroup) {
              return result = executorGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, featureCallback, executorGroup === _this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map(function(item) {
                return item.value;
              }) : null);
            });
            return result;
          };
          CanvasVectorLayerRenderer2.prototype.handleFontsChanged = function() {
            var layer = this.getLayer();
            if (layer.getVisible() && this.replayGroup_) {
              layer.changed();
            }
          };
          CanvasVectorLayerRenderer2.prototype.handleStyleImageChange_ = function(event) {
            this.renderIfReadyAndVisible();
          };
          CanvasVectorLayerRenderer2.prototype.prepareFrame = function(frameState) {
            var vectorLayer = this.getLayer();
            var vectorSource = vectorLayer.getSource();
            if (!vectorSource) {
              return false;
            }
            var animating = frameState.viewHints[ViewHint.ANIMATING];
            var interacting = frameState.viewHints[ViewHint.INTERACTING];
            var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
            var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
            if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
              this.animatingOrInteracting_ = true;
              return true;
            }
            this.animatingOrInteracting_ = false;
            var frameStateExtent = frameState.extent;
            var viewState = frameState.viewState;
            var projection = viewState.projection;
            var resolution = viewState.resolution;
            var pixelRatio = frameState.pixelRatio;
            var vectorLayerRevision = vectorLayer.getRevision();
            var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
            var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
            if (vectorLayerRenderOrder === void 0) {
              vectorLayerRenderOrder = defaultOrder;
            }
            var center = viewState.center.slice();
            var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
            var renderedExtent = extent.slice();
            var loadExtents = [extent.slice()];
            var projectionExtent = projection.getExtent();
            if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
              var worldWidth = getWidth(projectionExtent);
              var gutter = Math.max(getWidth(extent) / 2, worldWidth);
              extent[0] = projectionExtent[0] - gutter;
              extent[2] = projectionExtent[2] + gutter;
              wrapX(center, projection);
              var loadExtent = wrapX$1(loadExtents[0], projection);
              if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
                loadExtents.push([
                  loadExtent[0] + worldWidth,
                  loadExtent[1],
                  loadExtent[2] + worldWidth,
                  loadExtent[3]
                ]);
              } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
                loadExtents.push([
                  loadExtent[0] - worldWidth,
                  loadExtent[1],
                  loadExtent[2] - worldWidth,
                  loadExtent[3]
                ]);
              }
            }
            if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
              if (!equals$1(this.renderedExtent_, renderedExtent)) {
                this.hitDetectionImageData_ = null;
                this.renderedExtent_ = renderedExtent;
              }
              this.renderedCenter_ = center;
              this.replayGroupChanged = false;
              return true;
            }
            this.replayGroup_ = null;
            this.dirty_ = false;
            var replayGroup = new CanvasBuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
            var declutterBuilderGroup;
            if (this.getLayer().getDeclutter()) {
              declutterBuilderGroup = new CanvasBuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio);
            }
            var userTransform;
            var i, ii;
            {
              for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                vectorSource.loadFeatures(loadExtents[i], resolution, projection);
              }
            }
            var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
            var render = (
              /**
               * @param {import("../../Feature.js").default} feature Feature.
               * @this {CanvasVectorLayerRenderer}
               */
              (function(feature) {
                var styles;
                var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
                if (styleFunction) {
                  styles = styleFunction(feature, resolution);
                }
                if (styles) {
                  var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform, declutterBuilderGroup);
                  this.dirty_ = this.dirty_ || dirty;
                }
              }).bind(this)
            );
            var userExtent = toUserExtent(extent);
            var features = vectorSource.getFeaturesInExtent(userExtent);
            if (vectorLayerRenderOrder) {
              features.sort(vectorLayerRenderOrder);
            }
            for (var i = 0, ii = features.length; i < ii; ++i) {
              render(features[i]);
            }
            this.renderedFeatures_ = features;
            var replayGroupInstructions = replayGroup.finish();
            var executorGroup = new ExecutorGroup$1(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
            if (declutterBuilderGroup) {
              this.declutterExecutorGroup = new ExecutorGroup$1(extent, resolution, pixelRatio, vectorSource.getOverlaps(), declutterBuilderGroup.finish(), vectorLayer.getRenderBuffer());
            }
            this.renderedResolution_ = resolution;
            this.renderedRevision_ = vectorLayerRevision;
            this.renderedRenderOrder_ = vectorLayerRenderOrder;
            this.renderedExtent_ = renderedExtent;
            this.wrappedRenderedExtent_ = extent;
            this.renderedCenter_ = center;
            this.renderedProjection_ = projection;
            this.replayGroup_ = executorGroup;
            this.hitDetectionImageData_ = null;
            this.replayGroupChanged = true;
            return true;
          };
          CanvasVectorLayerRenderer2.prototype.renderFeature = function(feature, squaredTolerance, styles, builderGroup, opt_transform, opt_declutterBuilderGroup) {
            if (!styles) {
              return false;
            }
            var loading = false;
            if (Array.isArray(styles)) {
              for (var i = 0, ii = styles.length; i < ii; ++i) {
                loading = renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup) || loading;
              }
            } else {
              loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform, opt_declutterBuilderGroup);
            }
            return loading;
          };
          return CanvasVectorLayerRenderer2;
        }(CanvasLayerRenderer$1)
      );
      var CanvasVectorLayerRenderer$1 = CanvasVectorLayerRenderer;
      var __extends$6 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var VectorLayer = (
        /** @class */
        function(_super) {
          __extends$6(VectorLayer2, _super);
          function VectorLayer2(opt_options) {
            return _super.call(this, opt_options) || this;
          }
          VectorLayer2.prototype.createRenderer = function() {
            return new CanvasVectorLayerRenderer$1(this);
          };
          return VectorLayer2;
        }(BaseVectorLayer$1)
      );
      var VectorLayer$1 = VectorLayer;
      var CollectionEventType = {
        /**
         * Triggered when an item is added to the collection.
         * @event module:ol/Collection.CollectionEvent#add
         * @api
         */
        ADD: "add",
        /**
         * Triggered when an item is removed from the collection.
         * @event module:ol/Collection.CollectionEvent#remove
         * @api
         */
        REMOVE: "remove"
      };
      var __extends$5 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Property = {
        LENGTH: "length"
      };
      var CollectionEvent = (
        /** @class */
        function(_super) {
          __extends$5(CollectionEvent2, _super);
          function CollectionEvent2(type, opt_element, opt_index) {
            var _this = _super.call(this, type) || this;
            _this.element = opt_element;
            _this.index = opt_index;
            return _this;
          }
          return CollectionEvent2;
        }(Event)
      );
      var Collection = (
        /** @class */
        function(_super) {
          __extends$5(Collection2, _super);
          function Collection2(opt_array, opt_options) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            var options = opt_options || {};
            _this.unique_ = !!options.unique;
            _this.array_ = opt_array ? opt_array : [];
            if (_this.unique_) {
              for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                _this.assertUnique_(_this.array_[i], i);
              }
            }
            _this.updateLength_();
            return _this;
          }
          Collection2.prototype.clear = function() {
            while (this.getLength() > 0) {
              this.pop();
            }
          };
          Collection2.prototype.extend = function(arr) {
            for (var i = 0, ii = arr.length; i < ii; ++i) {
              this.push(arr[i]);
            }
            return this;
          };
          Collection2.prototype.forEach = function(f) {
            var array = this.array_;
            for (var i = 0, ii = array.length; i < ii; ++i) {
              f(array[i], i, array);
            }
          };
          Collection2.prototype.getArray = function() {
            return this.array_;
          };
          Collection2.prototype.item = function(index) {
            return this.array_[index];
          };
          Collection2.prototype.getLength = function() {
            return this.get(Property.LENGTH);
          };
          Collection2.prototype.insertAt = function(index, elem) {
            if (this.unique_) {
              this.assertUnique_(elem);
            }
            this.array_.splice(index, 0, elem);
            this.updateLength_();
            this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
          };
          Collection2.prototype.pop = function() {
            return this.removeAt(this.getLength() - 1);
          };
          Collection2.prototype.push = function(elem) {
            if (this.unique_) {
              this.assertUnique_(elem);
            }
            var n = this.getLength();
            this.insertAt(n, elem);
            return this.getLength();
          };
          Collection2.prototype.remove = function(elem) {
            var arr = this.array_;
            for (var i = 0, ii = arr.length; i < ii; ++i) {
              if (arr[i] === elem) {
                return this.removeAt(i);
              }
            }
            return void 0;
          };
          Collection2.prototype.removeAt = function(index) {
            var prev = this.array_[index];
            this.array_.splice(index, 1);
            this.updateLength_();
            this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
            return prev;
          };
          Collection2.prototype.setAt = function(index, elem) {
            var n = this.getLength();
            if (index < n) {
              if (this.unique_) {
                this.assertUnique_(elem, index);
              }
              var prev = this.array_[index];
              this.array_[index] = elem;
              this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
              this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
            } else {
              for (var j = n; j < index; ++j) {
                this.insertAt(j, void 0);
              }
              this.insertAt(index, elem);
            }
          };
          Collection2.prototype.updateLength_ = function() {
            this.set(Property.LENGTH, this.array_.length);
          };
          Collection2.prototype.assertUnique_ = function(elem, opt_except) {
            for (var i = 0, ii = this.array_.length; i < ii; ++i) {
              if (this.array_[i] === elem && i !== opt_except) {
                throw new AssertionError$1(58);
              }
            }
          };
          return Collection2;
        }(BaseObject$1)
      );
      var Collection$1 = Collection;
      var RBush = (
        /** @class */
        function() {
          function RBush2(opt_maxEntries) {
            this.rbush_ = new RBush$2(opt_maxEntries);
            this.items_ = {};
          }
          RBush2.prototype.insert = function(extent, value) {
            var item = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3],
              value
            };
            this.rbush_.insert(item);
            this.items_[getUid(value)] = item;
          };
          RBush2.prototype.load = function(extents, values) {
            var items = new Array(values.length);
            for (var i = 0, l = values.length; i < l; i++) {
              var extent = extents[i];
              var value = values[i];
              var item = {
                minX: extent[0],
                minY: extent[1],
                maxX: extent[2],
                maxY: extent[3],
                value
              };
              items[i] = item;
              this.items_[getUid(value)] = item;
            }
            this.rbush_.load(items);
          };
          RBush2.prototype.remove = function(value) {
            var uid = getUid(value);
            var item = this.items_[uid];
            delete this.items_[uid];
            return this.rbush_.remove(item) !== null;
          };
          RBush2.prototype.update = function(extent, value) {
            var item = this.items_[getUid(value)];
            var bbox = [item.minX, item.minY, item.maxX, item.maxY];
            if (!equals(bbox, extent)) {
              this.remove(value);
              this.insert(extent, value);
            }
          };
          RBush2.prototype.getAll = function() {
            var items = this.rbush_.all();
            return items.map(function(item) {
              return item.value;
            });
          };
          RBush2.prototype.getInExtent = function(extent) {
            var bbox = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3]
            };
            var items = this.rbush_.search(bbox);
            return items.map(function(item) {
              return item.value;
            });
          };
          RBush2.prototype.forEach = function(callback) {
            return this.forEach_(this.getAll(), callback);
          };
          RBush2.prototype.forEachInExtent = function(extent, callback) {
            return this.forEach_(this.getInExtent(extent), callback);
          };
          RBush2.prototype.forEach_ = function(values, callback) {
            var result;
            for (var i = 0, l = values.length; i < l; i++) {
              result = callback(values[i]);
              if (result) {
                return result;
              }
            }
            return result;
          };
          RBush2.prototype.isEmpty = function() {
            return isEmpty(this.items_);
          };
          RBush2.prototype.clear = function() {
            this.rbush_.clear();
            this.items_ = {};
          };
          RBush2.prototype.getExtent = function(opt_extent) {
            var data = this.rbush_.toJSON();
            return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
          };
          RBush2.prototype.concat = function(rbush) {
            this.rbush_.load(rbush.rbush_.all());
            for (var i in rbush.items_) {
              this.items_[i] = rbush.items_[i];
            }
          };
          return RBush2;
        }()
      );
      var RBush$1 = RBush;
      var __extends$4 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Source = (
        /** @class */
        function(_super) {
          __extends$4(Source2, _super);
          function Source2(options) {
            var _this = _super.call(this) || this;
            _this.projection = get$1(options.projection);
            _this.attributions_ = adaptAttributions(options.attributions);
            _this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
            _this.loading = false;
            _this.state_ = options.state !== void 0 ? options.state : SourceState.READY;
            _this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
            _this.interpolate_ = !!options.interpolate;
            _this.viewResolver = null;
            _this.viewRejector = null;
            var self2 = _this;
            _this.viewPromise_ = new Promise(function(resolve, reject) {
              self2.viewResolver = resolve;
              self2.viewRejector = reject;
            });
            return _this;
          }
          Source2.prototype.getAttributions = function() {
            return this.attributions_;
          };
          Source2.prototype.getAttributionsCollapsible = function() {
            return this.attributionsCollapsible_;
          };
          Source2.prototype.getProjection = function() {
            return this.projection;
          };
          Source2.prototype.getResolutions = function() {
            return abstract();
          };
          Source2.prototype.getView = function() {
            return this.viewPromise_;
          };
          Source2.prototype.getState = function() {
            return this.state_;
          };
          Source2.prototype.getWrapX = function() {
            return this.wrapX_;
          };
          Source2.prototype.getInterpolate = function() {
            return this.interpolate_;
          };
          Source2.prototype.refresh = function() {
            this.changed();
          };
          Source2.prototype.setAttributions = function(attributions) {
            this.attributions_ = adaptAttributions(attributions);
            this.changed();
          };
          Source2.prototype.setState = function(state) {
            this.state_ = state;
            this.changed();
          };
          return Source2;
        }(BaseObject$1)
      );
      function adaptAttributions(attributionLike) {
        if (!attributionLike) {
          return null;
        }
        if (Array.isArray(attributionLike)) {
          return function(frameState) {
            return attributionLike;
          };
        }
        if (typeof attributionLike === "function") {
          return attributionLike;
        }
        return function(frameState) {
          return [attributionLike];
        };
      }
      var Source$1 = Source;
      var VectorEventType = {
        /**
         * Triggered when a feature is added to the source.
         * @event module:ol/source/Vector.VectorSourceEvent#addfeature
         * @api
         */
        ADDFEATURE: "addfeature",
        /**
         * Triggered when a feature is updated.
         * @event module:ol/source/Vector.VectorSourceEvent#changefeature
         * @api
         */
        CHANGEFEATURE: "changefeature",
        /**
         * Triggered when the clear method is called on the source.
         * @event module:ol/source/Vector.VectorSourceEvent#clear
         * @api
         */
        CLEAR: "clear",
        /**
         * Triggered when a feature is removed from the source.
         * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
         * @event module:ol/source/Vector.VectorSourceEvent#removefeature
         * @api
         */
        REMOVEFEATURE: "removefeature",
        /**
         * Triggered when features starts loading.
         * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
         * @api
         */
        FEATURESLOADSTART: "featuresloadstart",
        /**
         * Triggered when features finishes loading.
         * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
         * @api
         */
        FEATURESLOADEND: "featuresloadend",
        /**
         * Triggered if feature loading results in an error.
         * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
         * @api
         */
        FEATURESLOADERROR: "featuresloaderror"
      };
      function all(extent, resolution) {
        return [[-Infinity, -Infinity, Infinity, Infinity]];
      }
      var FormatType = {
        ARRAY_BUFFER: "arraybuffer",
        JSON: "json",
        TEXT: "text",
        XML: "xml"
      };
      var withCredentials = false;
      function loadFeaturesXhr(url, format, extent, resolution, projection, success, failure) {
        var xhr2 = new XMLHttpRequest();
        xhr2.open("GET", typeof url === "function" ? url(extent, resolution, projection) : url, true);
        if (format.getType() == FormatType.ARRAY_BUFFER) {
          xhr2.responseType = "arraybuffer";
        }
        xhr2.withCredentials = withCredentials;
        xhr2.onload = function(event) {
          if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
            var type = format.getType();
            var source = void 0;
            if (type == FormatType.JSON || type == FormatType.TEXT) {
              source = xhr2.responseText;
            } else if (type == FormatType.XML) {
              source = xhr2.responseXML;
              if (!source) {
                source = new DOMParser().parseFromString(xhr2.responseText, "application/xml");
              }
            } else if (type == FormatType.ARRAY_BUFFER) {
              source = /** @type {ArrayBuffer} */
              xhr2.response;
            }
            if (source) {
              success(
                /** @type {Array<import("./Feature.js").default>} */
                format.readFeatures(source, {
                  extent,
                  featureProjection: projection
                }),
                format.readProjection(source)
              );
            } else {
              failure();
            }
          } else {
            failure();
          }
        };
        xhr2.onerror = failure;
        xhr2.send();
      }
      function xhr(url, format) {
        return function(extent, resolution, projection, success, failure) {
          var source = (
            /** @type {import("./source/Vector").default} */
            this
          );
          loadFeaturesXhr(
            url,
            format,
            extent,
            resolution,
            projection,
            /**
             * @param {Array<import("./Feature.js").default>} features The loaded features.
             * @param {import("./proj/Projection.js").default} dataProjection Data
             * projection.
             */
            function(features, dataProjection) {
              source.addFeatures(features);
              if (success !== void 0) {
                success(features);
              }
            },
            /* FIXME handle error */
            failure ? failure : VOID
          );
        };
      }
      var __extends$3 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var VectorSourceEvent = (
        /** @class */
        function(_super) {
          __extends$3(VectorSourceEvent2, _super);
          function VectorSourceEvent2(type, opt_feature, opt_features) {
            var _this = _super.call(this, type) || this;
            _this.feature = opt_feature;
            _this.features = opt_features;
            return _this;
          }
          return VectorSourceEvent2;
        }(Event)
      );
      var VectorSource = (
        /** @class */
        function(_super) {
          __extends$3(VectorSource2, _super);
          function VectorSource2(opt_options) {
            var _this = this;
            var options = opt_options || {};
            _this = _super.call(this, {
              attributions: options.attributions,
              interpolate: true,
              projection: void 0,
              state: SourceState.READY,
              wrapX: options.wrapX !== void 0 ? options.wrapX : true
            }) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.loader_ = VOID;
            _this.format_ = options.format;
            _this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
            _this.url_ = options.url;
            if (options.loader !== void 0) {
              _this.loader_ = options.loader;
            } else if (_this.url_ !== void 0) {
              assert(_this.format_, 7);
              _this.loader_ = xhr(
                _this.url_,
                /** @type {import("../format/Feature.js").default} */
                _this.format_
              );
            }
            _this.strategy_ = options.strategy !== void 0 ? options.strategy : all;
            var useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
            _this.featuresRtree_ = useSpatialIndex ? new RBush$1() : null;
            _this.loadedExtentsRtree_ = new RBush$1();
            _this.loadingExtentsCount_ = 0;
            _this.nullGeometryFeatures_ = {};
            _this.idIndex_ = {};
            _this.uidIndex_ = {};
            _this.featureChangeKeys_ = {};
            _this.featuresCollection_ = null;
            var collection, features;
            if (Array.isArray(options.features)) {
              features = /** @type {Array<import("../Feature.js").default<Geometry>>} */
              options.features;
            } else if (options.features) {
              collection = /** @type {Collection<import("../Feature.js").default<Geometry>>} */
              options.features;
              features = collection.getArray();
            }
            if (!useSpatialIndex && collection === void 0) {
              collection = new Collection$1(features);
            }
            if (features !== void 0) {
              _this.addFeaturesInternal(features);
            }
            if (collection !== void 0) {
              _this.bindFeaturesCollection_(collection);
            }
            return _this;
          }
          VectorSource2.prototype.addFeature = function(feature) {
            this.addFeatureInternal(feature);
            this.changed();
          };
          VectorSource2.prototype.addFeatureInternal = function(feature) {
            var featureKey = getUid(feature);
            if (!this.addToIndex_(featureKey, feature)) {
              if (this.featuresCollection_) {
                this.featuresCollection_.remove(feature);
              }
              return;
            }
            this.setupChangeEvents_(featureKey, feature);
            var geometry = feature.getGeometry();
            if (geometry) {
              var extent = geometry.getExtent();
              if (this.featuresRtree_) {
                this.featuresRtree_.insert(extent, feature);
              }
            } else {
              this.nullGeometryFeatures_[featureKey] = feature;
            }
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
          };
          VectorSource2.prototype.setupChangeEvents_ = function(featureKey, feature) {
            this.featureChangeKeys_[featureKey] = [
              listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),
              listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)
            ];
          };
          VectorSource2.prototype.addToIndex_ = function(featureKey, feature) {
            var valid = true;
            var id = feature.getId();
            if (id !== void 0) {
              if (!(id.toString() in this.idIndex_)) {
                this.idIndex_[id.toString()] = feature;
              } else {
                valid = false;
              }
            }
            if (valid) {
              assert(!(featureKey in this.uidIndex_), 30);
              this.uidIndex_[featureKey] = feature;
            }
            return valid;
          };
          VectorSource2.prototype.addFeatures = function(features) {
            this.addFeaturesInternal(features);
            this.changed();
          };
          VectorSource2.prototype.addFeaturesInternal = function(features) {
            var extents = [];
            var newFeatures = [];
            var geometryFeatures = [];
            for (var i = 0, length_1 = features.length; i < length_1; i++) {
              var feature = features[i];
              var featureKey = getUid(feature);
              if (this.addToIndex_(featureKey, feature)) {
                newFeatures.push(feature);
              }
            }
            for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
              var feature = newFeatures[i];
              var featureKey = getUid(feature);
              this.setupChangeEvents_(featureKey, feature);
              var geometry = feature.getGeometry();
              if (geometry) {
                var extent = geometry.getExtent();
                extents.push(extent);
                geometryFeatures.push(feature);
              } else {
                this.nullGeometryFeatures_[featureKey] = feature;
              }
            }
            if (this.featuresRtree_) {
              this.featuresRtree_.load(extents, geometryFeatures);
            }
            if (this.hasListener(VectorEventType.ADDFEATURE)) {
              for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));
              }
            }
          };
          VectorSource2.prototype.bindFeaturesCollection_ = function(collection) {
            var modifyingCollection = false;
            this.addEventListener(
              VectorEventType.ADDFEATURE,
              /**
               * @param {VectorSourceEvent<Geometry>} evt The vector source event
               */
              function(evt) {
                if (!modifyingCollection) {
                  modifyingCollection = true;
                  collection.push(evt.feature);
                  modifyingCollection = false;
                }
              }
            );
            this.addEventListener(
              VectorEventType.REMOVEFEATURE,
              /**
               * @param {VectorSourceEvent<Geometry>} evt The vector source event
               */
              function(evt) {
                if (!modifyingCollection) {
                  modifyingCollection = true;
                  collection.remove(evt.feature);
                  modifyingCollection = false;
                }
              }
            );
            collection.addEventListener(
              CollectionEventType.ADD,
              /**
               * @param {import("../Collection.js").CollectionEvent} evt The collection event
               */
              (function(evt) {
                if (!modifyingCollection) {
                  modifyingCollection = true;
                  this.addFeature(
                    /** @type {import("../Feature.js").default<Geometry>} */
                    evt.element
                  );
                  modifyingCollection = false;
                }
              }).bind(this)
            );
            collection.addEventListener(
              CollectionEventType.REMOVE,
              /**
               * @param {import("../Collection.js").CollectionEvent} evt The collection event
               */
              (function(evt) {
                if (!modifyingCollection) {
                  modifyingCollection = true;
                  this.removeFeature(
                    /** @type {import("../Feature.js").default<Geometry>} */
                    evt.element
                  );
                  modifyingCollection = false;
                }
              }).bind(this)
            );
            this.featuresCollection_ = collection;
          };
          VectorSource2.prototype.clear = function(opt_fast) {
            if (opt_fast) {
              for (var featureId in this.featureChangeKeys_) {
                var keys = this.featureChangeKeys_[featureId];
                keys.forEach(unlistenByKey);
              }
              if (!this.featuresCollection_) {
                this.featureChangeKeys_ = {};
                this.idIndex_ = {};
                this.uidIndex_ = {};
              }
            } else {
              if (this.featuresRtree_) {
                var removeAndIgnoreReturn = (function(feature) {
                  this.removeFeatureInternal(feature);
                }).bind(this);
                this.featuresRtree_.forEach(removeAndIgnoreReturn);
                for (var id in this.nullGeometryFeatures_) {
                  this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                }
              }
            }
            if (this.featuresCollection_) {
              this.featuresCollection_.clear();
            }
            if (this.featuresRtree_) {
              this.featuresRtree_.clear();
            }
            this.nullGeometryFeatures_ = {};
            var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
            this.dispatchEvent(clearEvent);
            this.changed();
          };
          VectorSource2.prototype.forEachFeature = function(callback) {
            if (this.featuresRtree_) {
              return this.featuresRtree_.forEach(callback);
            } else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
            }
          };
          VectorSource2.prototype.forEachFeatureAtCoordinateDirect = function(coordinate, callback) {
            var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
            return this.forEachFeatureInExtent(extent, function(feature) {
              var geometry = feature.getGeometry();
              if (geometry.intersectsCoordinate(coordinate)) {
                return callback(feature);
              } else {
                return void 0;
              }
            });
          };
          VectorSource2.prototype.forEachFeatureInExtent = function(extent, callback) {
            if (this.featuresRtree_) {
              return this.featuresRtree_.forEachInExtent(extent, callback);
            } else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
            }
          };
          VectorSource2.prototype.forEachFeatureIntersectingExtent = function(extent, callback) {
            return this.forEachFeatureInExtent(
              extent,
              /**
               * @param {import("../Feature.js").default<Geometry>} feature Feature.
               * @return {T|undefined} The return value from the last call to the callback.
               */
              function(feature) {
                var geometry = feature.getGeometry();
                if (geometry.intersectsExtent(extent)) {
                  var result = callback(feature);
                  if (result) {
                    return result;
                  }
                }
              }
            );
          };
          VectorSource2.prototype.getFeaturesCollection = function() {
            return this.featuresCollection_;
          };
          VectorSource2.prototype.getFeatures = function() {
            var features;
            if (this.featuresCollection_) {
              features = this.featuresCollection_.getArray().slice(0);
            } else if (this.featuresRtree_) {
              features = this.featuresRtree_.getAll();
              if (!isEmpty(this.nullGeometryFeatures_)) {
                extend$1(features, getValues(this.nullGeometryFeatures_));
              }
            }
            return (
              /** @type {Array<import("../Feature.js").default<Geometry>>} */
              features
            );
          };
          VectorSource2.prototype.getFeaturesAtCoordinate = function(coordinate) {
            var features = [];
            this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
              features.push(feature);
            });
            return features;
          };
          VectorSource2.prototype.getFeaturesInExtent = function(extent) {
            if (this.featuresRtree_) {
              return this.featuresRtree_.getInExtent(extent);
            } else if (this.featuresCollection_) {
              return this.featuresCollection_.getArray().slice(0);
            } else {
              return [];
            }
          };
          VectorSource2.prototype.getClosestFeatureToCoordinate = function(coordinate, opt_filter) {
            var x = coordinate[0];
            var y = coordinate[1];
            var closestFeature = null;
            var closestPoint = [NaN, NaN];
            var minSquaredDistance = Infinity;
            var extent = [-Infinity, -Infinity, Infinity, Infinity];
            var filter = opt_filter ? opt_filter : TRUE;
            this.featuresRtree_.forEachInExtent(
              extent,
              /**
               * @param {import("../Feature.js").default<Geometry>} feature Feature.
               */
              function(feature) {
                if (filter(feature)) {
                  var geometry = feature.getGeometry();
                  var previousMinSquaredDistance = minSquaredDistance;
                  minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                  if (minSquaredDistance < previousMinSquaredDistance) {
                    closestFeature = feature;
                    var minDistance = Math.sqrt(minSquaredDistance);
                    extent[0] = x - minDistance;
                    extent[1] = y - minDistance;
                    extent[2] = x + minDistance;
                    extent[3] = y + minDistance;
                  }
                }
              }
            );
            return closestFeature;
          };
          VectorSource2.prototype.getExtent = function(opt_extent) {
            return this.featuresRtree_.getExtent(opt_extent);
          };
          VectorSource2.prototype.getFeatureById = function(id) {
            var feature = this.idIndex_[id.toString()];
            return feature !== void 0 ? feature : null;
          };
          VectorSource2.prototype.getFeatureByUid = function(uid) {
            var feature = this.uidIndex_[uid];
            return feature !== void 0 ? feature : null;
          };
          VectorSource2.prototype.getFormat = function() {
            return this.format_;
          };
          VectorSource2.prototype.getOverlaps = function() {
            return this.overlaps_;
          };
          VectorSource2.prototype.getUrl = function() {
            return this.url_;
          };
          VectorSource2.prototype.handleFeatureChange_ = function(event) {
            var feature = (
              /** @type {import("../Feature.js").default<Geometry>} */
              event.target
            );
            var featureKey = getUid(feature);
            var geometry = feature.getGeometry();
            if (!geometry) {
              if (!(featureKey in this.nullGeometryFeatures_)) {
                if (this.featuresRtree_) {
                  this.featuresRtree_.remove(feature);
                }
                this.nullGeometryFeatures_[featureKey] = feature;
              }
            } else {
              var extent = geometry.getExtent();
              if (featureKey in this.nullGeometryFeatures_) {
                delete this.nullGeometryFeatures_[featureKey];
                if (this.featuresRtree_) {
                  this.featuresRtree_.insert(extent, feature);
                }
              } else {
                if (this.featuresRtree_) {
                  this.featuresRtree_.update(extent, feature);
                }
              }
            }
            var id = feature.getId();
            if (id !== void 0) {
              var sid = id.toString();
              if (this.idIndex_[sid] !== feature) {
                this.removeFromIdIndex_(feature);
                this.idIndex_[sid] = feature;
              }
            } else {
              this.removeFromIdIndex_(feature);
              this.uidIndex_[featureKey] = feature;
            }
            this.changed();
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
          };
          VectorSource2.prototype.hasFeature = function(feature) {
            var id = feature.getId();
            if (id !== void 0) {
              return id in this.idIndex_;
            } else {
              return getUid(feature) in this.uidIndex_;
            }
          };
          VectorSource2.prototype.isEmpty = function() {
            if (this.featuresRtree_) {
              return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
            }
            if (this.featuresCollection_) {
              return this.featuresCollection_.getLength() === 0;
            }
            return true;
          };
          VectorSource2.prototype.loadFeatures = function(extent, resolution, projection) {
            var loadedExtentsRtree = this.loadedExtentsRtree_;
            var extentsToLoad = this.strategy_(extent, resolution, projection);
            var _loop_1 = function(i2, ii2) {
              var extentToLoad = extentsToLoad[i2];
              var alreadyLoaded = loadedExtentsRtree.forEachInExtent(
                extentToLoad,
                /**
                 * @param {{extent: import("../extent.js").Extent}} object Object.
                 * @return {boolean} Contains.
                 */
                function(object) {
                  return containsExtent(object.extent, extentToLoad);
                }
              );
              if (!alreadyLoaded) {
                ++this_1.loadingExtentsCount_;
                this_1.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART));
                this_1.loader_.call(this_1, extentToLoad, resolution, projection, (function(features) {
                  --this.loadingExtentsCount_;
                  this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND, void 0, features));
                }).bind(this_1), (function() {
                  --this.loadingExtentsCount_;
                  this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR));
                }).bind(this_1));
                loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
              }
            };
            var this_1 = this;
            for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
              _loop_1(i);
            }
            this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
          };
          VectorSource2.prototype.refresh = function() {
            this.clear(true);
            this.loadedExtentsRtree_.clear();
            _super.prototype.refresh.call(this);
          };
          VectorSource2.prototype.removeLoadedExtent = function(extent) {
            var loadedExtentsRtree = this.loadedExtentsRtree_;
            var obj;
            loadedExtentsRtree.forEachInExtent(extent, function(object) {
              if (equals(object.extent, extent)) {
                obj = object;
                return true;
              }
            });
            if (obj) {
              loadedExtentsRtree.remove(obj);
            }
          };
          VectorSource2.prototype.removeFeature = function(feature) {
            if (!feature) {
              return;
            }
            var featureKey = getUid(feature);
            if (featureKey in this.nullGeometryFeatures_) {
              delete this.nullGeometryFeatures_[featureKey];
            } else {
              if (this.featuresRtree_) {
                this.featuresRtree_.remove(feature);
              }
            }
            var result = this.removeFeatureInternal(feature);
            if (result) {
              this.changed();
            }
          };
          VectorSource2.prototype.removeFeatureInternal = function(feature) {
            var featureKey = getUid(feature);
            var featureChangeKeys = this.featureChangeKeys_[featureKey];
            if (!featureChangeKeys) {
              return;
            }
            featureChangeKeys.forEach(unlistenByKey);
            delete this.featureChangeKeys_[featureKey];
            var id = feature.getId();
            if (id !== void 0) {
              delete this.idIndex_[id.toString()];
            }
            delete this.uidIndex_[featureKey];
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
            return feature;
          };
          VectorSource2.prototype.removeFromIdIndex_ = function(feature) {
            var removed = false;
            for (var id in this.idIndex_) {
              if (this.idIndex_[id] === feature) {
                delete this.idIndex_[id];
                removed = true;
                break;
              }
            }
            return removed;
          };
          VectorSource2.prototype.setLoader = function(loader) {
            this.loader_ = loader;
          };
          VectorSource2.prototype.setUrl = function(url) {
            assert(this.format_, 7);
            this.url_ = url;
            this.setLoader(xhr(url, this.format_));
          };
          return VectorSource2;
        }(Source$1)
      );
      var VectorSource$1 = VectorSource;
      var __extends$2 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Feature = (
        /** @class */
        function(_super) {
          __extends$2(Feature2, _super);
          function Feature2(opt_geometryOrProperties) {
            var _this = _super.call(this) || this;
            _this.on;
            _this.once;
            _this.un;
            _this.id_ = void 0;
            _this.geometryName_ = "geometry";
            _this.style_ = null;
            _this.styleFunction_ = void 0;
            _this.geometryChangeKey_ = null;
            _this.addChangeListener(_this.geometryName_, _this.handleGeometryChanged_);
            if (opt_geometryOrProperties) {
              if (typeof /** @type {?} */
              opt_geometryOrProperties.getSimplifiedGeometry === "function") {
                var geometry = (
                  /** @type {Geometry} */
                  opt_geometryOrProperties
                );
                _this.setGeometry(geometry);
              } else {
                var properties = opt_geometryOrProperties;
                _this.setProperties(properties);
              }
            }
            return _this;
          }
          Feature2.prototype.clone = function() {
            var clone2 = (
              /** @type {Feature<Geometry>} */
              new Feature2(this.hasProperties() ? this.getProperties() : null)
            );
            clone2.setGeometryName(this.getGeometryName());
            var geometry = this.getGeometry();
            if (geometry) {
              clone2.setGeometry(
                /** @type {Geometry} */
                geometry.clone()
              );
            }
            var style = this.getStyle();
            if (style) {
              clone2.setStyle(style);
            }
            return clone2;
          };
          Feature2.prototype.getGeometry = function() {
            return (
              /** @type {Geometry|undefined} */
              this.get(this.geometryName_)
            );
          };
          Feature2.prototype.getId = function() {
            return this.id_;
          };
          Feature2.prototype.getGeometryName = function() {
            return this.geometryName_;
          };
          Feature2.prototype.getStyle = function() {
            return this.style_;
          };
          Feature2.prototype.getStyleFunction = function() {
            return this.styleFunction_;
          };
          Feature2.prototype.handleGeometryChange_ = function() {
            this.changed();
          };
          Feature2.prototype.handleGeometryChanged_ = function() {
            if (this.geometryChangeKey_) {
              unlistenByKey(this.geometryChangeKey_);
              this.geometryChangeKey_ = null;
            }
            var geometry = this.getGeometry();
            if (geometry) {
              this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
            }
            this.changed();
          };
          Feature2.prototype.setGeometry = function(geometry) {
            this.set(this.geometryName_, geometry);
          };
          Feature2.prototype.setStyle = function(opt_style) {
            this.style_ = opt_style;
            this.styleFunction_ = !opt_style ? void 0 : createStyleFunction(opt_style);
            this.changed();
          };
          Feature2.prototype.setId = function(id) {
            this.id_ = id;
            this.changed();
          };
          Feature2.prototype.setGeometryName = function(name) {
            this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
            this.geometryName_ = name;
            this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
            this.handleGeometryChanged_();
          };
          return Feature2;
        }(BaseObject$1)
      );
      function createStyleFunction(obj) {
        if (typeof obj === "function") {
          return obj;
        } else {
          var styles_1;
          if (Array.isArray(obj)) {
            styles_1 = obj;
          } else {
            assert(typeof /** @type {?} */
            obj.getZIndex === "function", 41);
            var style = (
              /** @type {import("./style/Style.js").default} */
              obj
            );
            styles_1 = [style];
          }
          return function() {
            return styles_1;
          };
        }
      }
      var Feature$1 = Feature;
      function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
        for (var i = 0, ii = coordinate.length; i < ii; ++i) {
          flatCoordinates[offset++] = coordinate[i];
        }
        return offset;
      }
      function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
        for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          var coordinate = coordinates[i];
          for (var j = 0; j < stride; ++j) {
            flatCoordinates[offset++] = coordinate[j];
          }
        }
        return offset;
      }
      var __extends$1 = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var Point = (
        /** @class */
        function(_super) {
          __extends$1(Point2, _super);
          function Point2(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            _this.setCoordinates(coordinates, opt_layout);
            return _this;
          }
          Point2.prototype.clone = function() {
            var point = new Point2(this.flatCoordinates.slice(), this.layout);
            point.applyProperties(this);
            return point;
          };
          Point2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            var flatCoordinates = this.flatCoordinates;
            var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
            if (squaredDistance$1 < minSquaredDistance) {
              var stride = this.stride;
              for (var i = 0; i < stride; ++i) {
                closestPoint[i] = flatCoordinates[i];
              }
              closestPoint.length = stride;
              return squaredDistance$1;
            } else {
              return minSquaredDistance;
            }
          };
          Point2.prototype.getCoordinates = function() {
            return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
          };
          Point2.prototype.computeExtent = function(extent) {
            return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
          };
          Point2.prototype.getType = function() {
            return GeometryType.POINT;
          };
          Point2.prototype.intersectsExtent = function(extent) {
            return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
          };
          Point2.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 0);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
          };
          return Point2;
        }(SimpleGeometry$1)
      );
      var Point$1 = Point;
      var __extends = /* @__PURE__ */ function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var MultiPoint = (
        /** @class */
        function(_super) {
          __extends(MultiPoint2, _super);
          function MultiPoint2(coordinates, opt_layout) {
            var _this = _super.call(this) || this;
            if (opt_layout && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(
                opt_layout,
                /** @type {Array<number>} */
                coordinates
              );
            } else {
              _this.setCoordinates(
                /** @type {Array<import("../coordinate.js").Coordinate>} */
                coordinates,
                opt_layout
              );
            }
            return _this;
          }
          MultiPoint2.prototype.appendPoint = function(point) {
            if (!this.flatCoordinates) {
              this.flatCoordinates = point.getFlatCoordinates().slice();
            } else {
              extend$1(this.flatCoordinates, point.getFlatCoordinates());
            }
            this.changed();
          };
          MultiPoint2.prototype.clone = function() {
            var multiPoint = new MultiPoint2(this.flatCoordinates.slice(), this.layout);
            multiPoint.applyProperties(this);
            return multiPoint;
          };
          MultiPoint2.prototype.closestPointXY = function(x, y, closestPoint, minSquaredDistance) {
            if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
            }
            var flatCoordinates = this.flatCoordinates;
            var stride = this.stride;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
              if (squaredDistance$1 < minSquaredDistance) {
                minSquaredDistance = squaredDistance$1;
                for (var j = 0; j < stride; ++j) {
                  closestPoint[j] = flatCoordinates[i + j];
                }
                closestPoint.length = stride;
              }
            }
            return minSquaredDistance;
          };
          MultiPoint2.prototype.getCoordinates = function() {
            return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
          };
          MultiPoint2.prototype.getPoint = function(index) {
            var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
            if (index < 0 || n <= index) {
              return null;
            }
            return new Point$1(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
          };
          MultiPoint2.prototype.getPoints = function() {
            var flatCoordinates = this.flatCoordinates;
            var layout = this.layout;
            var stride = this.stride;
            var points = [];
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var point = new Point$1(flatCoordinates.slice(i, i + stride), layout);
              points.push(point);
            }
            return points;
          };
          MultiPoint2.prototype.getType = function() {
            return GeometryType.MULTI_POINT;
          };
          MultiPoint2.prototype.intersectsExtent = function(extent) {
            var flatCoordinates = this.flatCoordinates;
            var stride = this.stride;
            for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              if (containsXY(extent, x, y)) {
                return true;
              }
            }
            return false;
          };
          MultiPoint2.prototype.setCoordinates = function(coordinates, opt_layout) {
            this.setLayout(opt_layout, coordinates, 1);
            if (!this.flatCoordinates) {
              this.flatCoordinates = [];
            }
            this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
            this.changed();
          };
          return MultiPoint2;
        }(SimpleGeometry$1)
      );
      var MultiPoint$1 = MultiPoint;
      const DEFAULT_ORIGIN_COORDINATE = [0, 0];
      const DEFAULT_GRID_SIZE = 10;
      const DEFAULT_MAX_POINTS_PER_SIDE = 64;
      class Grid extends Interaction$1 {
        /**
         * @param {Options=} opt_options Options.
         */
        constructor(opt_options) {
          const options = opt_options ? opt_options : {};
          super(
            /** @type {Interaction.InteractionOptions} */
            options
          );
          this.originCoordinate = options.originCoordinate || DEFAULT_ORIGIN_COORDINATE;
          this.rotationAnchorCoordinate = options.rotationAnchorCoordinate || null;
          this.xGridSize = options.xGridSize || DEFAULT_GRID_SIZE;
          this.yGridSize = options.yGridSize || DEFAULT_GRID_SIZE;
          this.maxPointsPerSide = options.maxPointsPerSide || DEFAULT_MAX_POINTS_PER_SIDE;
          this.overlay_ = new VectorLayer$1({
            source: createAlwaysVisibleVectorSource(),
            style: options.style,
            updateWhileInteracting: true
          });
          this.gridFeature_ = new Feature$1({
            geometry: new MultiPoint$1([])
          });
          this.updateGridDescription_();
          this.overlay_.getSource().addFeature(this.gridFeature_);
          this.overlay_.on("postrender", this.handleGridLayerPostRender_.bind(this));
          this.addEventListener("change:active", this.updateState_);
        }
        /**
         * Get a feature containing the current grid points. Callers should not
         * modify the feature or its geometry, but may use it to modify the behavior
         * of the map - such as adding it to a Snap interaction. The feature geometry
         * is empty when the grid is not active.
         * @return {Feature} grid feature with a single MultiPoint geometry.
         * @api
         */
        getGridFeature() {
          return this.gridFeature_;
        }
        /**
         * Set the origin coordinate for the grid.
         * @param {ol.Coordinate} originCoordinate Coordinate.
         * @api
         */
        setOriginPoint(originCoordinate) {
          this.originCoordinate = originCoordinate;
          this.updateGridDescription_();
        }
        /**
         * Set the rotation anchor coordinate used to control how the rid is rotated.
         * @param {ol.Coordinate} rotationAnchorCoordinate Coordinate.
         * @api
         */
        setRotationControlPoint(rotationAnchorCoordinate) {
          this.rotationAnchorCoordinate = rotationAnchorCoordinate;
          this.updateGridDescription_();
        }
        /**
         * Set the x grid size. If the origin point and rotation anchor point have the
         * same latitude, then this sets the horizontal (width) of the grid cells.
         * @param {number} xGridSize number in map units.
         * @api
         */
        setXGridSize(xGridSize) {
          this.xGridSize = xGridSize;
          this.updateGridDescription_();
        }
        /**
         * Set the y grid size. If the origin point and rotation anchor point have the
         * same latitude, then this sets the vertical (height) of the grid cells.
         * @param {number} yGridSize number in map units.
         * @api
         */
        setYGridSize(yGridSize) {
          this.yGridSize = yGridSize;
          this.updateGridDescription_();
        }
        /**
         * Set the max number of points per side. Controls the maximum number of points
         * to be drawn on the screen at one time.
         * @param {number} maxPointsPerSide number of points per side.
         * @api
         */
        setMaxPointsPerSide(maxPointsPerSide) {
          this.maxPointsPerSide = maxPointsPerSide;
          this.changed();
        }
        /**
         * Set the style of the grid points.
         * @param {ol.style.StyleLike} style of the grid points.
         * @api
         */
        setStyle(style) {
          this.overlay_.setStyle(style);
        }
        /**
         * @param {ol.PluggableMap} map Map.
         */
        setMap(map) {
          super.setMap(map);
          this.updateState_();
        }
        /**
         * @private
         */
        updateState_() {
          const map = this.getMap();
          const active = this.getActive();
          this.overlay_.setMap(active ? map : null);
          this.updateGridDescription_();
        }
        /**
         * @private
         */
        updateGridDescription_() {
          const map = this.getMap();
          if (!map || !this.originCoordinate || !this.xGridSize || !this.yGridSize || !this.getActive()) {
            this.gridDescription_ = null;
            this.lastGridDescription_ = null;
            this.gridFeature_.getGeometry().setCoordinates([]);
            this.changed();
            return;
          }
          const mapViewProj = map.getView().getProjection();
          const cp1 = transform(this.originCoordinate, mapViewProj, "EPSG:4326");
          const rotationAnchorCoordinate = this.rotationAnchorCoordinate || addVectors(this.originCoordinate, [1, 0]);
          const cp2 = transform(rotationAnchorCoordinate, mapViewProj, "EPSG:4326");
          const cp3 = [cp1[0], cp2[1]];
          const cp4 = [cp2[0], cp1[1]];
          const len = getDistance(cp1, cp2);
          let rise = getDistance(cp1, cp3);
          let run = getDistance(cp1, cp4);
          if (cp1[0] > cp2[0]) {
            run *= -1;
          }
          if (cp1[1] > cp2[1]) {
            rise *= -1;
          }
          const riseFactor = rise / len;
          const runFactor = run / len;
          !this.gridDescription_;
          this.gridDescription_ = {
            originCoordinate: this.originCoordinate,
            riseFactor,
            runFactor,
            xDim: this.xGridSize,
            yDim: this.yGridSize
          };
          this.changed();
        }
        /**
         * @inheritDoc
         * @api
         */
        changed() {
          super.changed();
          this.overlay_.changed();
        }
        /**
         * Handle post render events for our grid layer
         * @param {ol.render.Event} event A render event.
         * @private
         */
        handleGridLayerPostRender_(event) {
          const map = this.getMap();
          const gridDescription = this.gridDescription_;
          if (!gridDescription) {
            return;
          }
          const viewExtent = map.getView().calculateExtent(map.getSize());
          const gridDescriptionUnchanged = gridDescription === this.lastGridDescription_ || JSON.stringify(gridDescription) === JSON.stringify(this.lastGridDescription_);
          const viewExtentUnchanged = viewExtent === this.lastViewExtent_ || JSON.stringify(viewExtent) === JSON.stringify(this.lastViewExtent_);
          if (gridDescriptionUnchanged && viewExtentUnchanged) {
            return;
          }
          const selectedOriginCoords = gridDescription.originCoordinate;
          let xBasisVector = [
            gridDescription.xDim * gridDescription.runFactor,
            gridDescription.xDim * gridDescription.riseFactor
          ];
          let yBasisVector = [
            gridDescription.yDim * -1 * gridDescription.riseFactor,
            gridDescription.yDim * gridDescription.runFactor
          ];
          const localSphereNormalizationCoefficients = this.calculateLocalSphereNormalizationCoefficients(new Point$1(gridDescription.originCoordinate));
          xBasisVector = elementWiseVectorProduct(
            xBasisVector,
            localSphereNormalizationCoefficients
          );
          yBasisVector = elementWiseVectorProduct(
            yBasisVector,
            localSphereNormalizationCoefficients
          );
          const viewExtentCenter = getCenter(viewExtent);
          const viewCenterCoordinateVector = getAlignedIntegerCoordinateVector(
            selectedOriginCoords,
            xBasisVector,
            yBasisVector,
            viewExtentCenter
          );
          const vOriginCoords = addVectors(selectedOriginCoords, multiplyTwoByTwoMatrixByTwoVector(
            [xBasisVector, yBasisVector],
            viewCenterCoordinateVector
          ));
          const vOrigin = new Point$1(vOriginCoords);
          const vGridExtentCoordinateVectors = getCoordinateVectorsToExtentCorners(
            vOriginCoords,
            xBasisVector,
            yBasisVector,
            viewExtent
          );
          const gridPoints = calculateGridPoints(
            viewExtent,
            vOrigin,
            vGridExtentCoordinateVectors,
            xBasisVector,
            yBasisVector,
            this.maxPointsPerSide
          );
          this.lastGridDescription_ = gridDescription;
          this.lastViewExtent_ = viewExtent;
          this.gridFeature_.getGeometry().setCoordinates(gridPoints);
        }
        calculateLocalSphereNormalizationCoefficients(origin) {
          const mapViewProjCode = this.getMap().getView().getProjection().getCode();
          function asEpsg4326Coords(point) {
            return point.transform(mapViewProjCode, "EPSG:4326").getCoordinates();
          }
          function translateCopy(point, deltaX, deltaY) {
            const p = point.clone();
            p.translate(deltaX, deltaY);
            return p;
          }
          const originCoords = asEpsg4326Coords(origin.clone());
          const testXCoords = asEpsg4326Coords(translateCopy(origin, 1, 0));
          const testYCoords = asEpsg4326Coords(translateCopy(origin, 0, 1));
          return [
            1 / getDistance(originCoords, testXCoords),
            1 / getDistance(originCoords, testYCoords)
          ];
        }
      }
      function getGridPoint(vOrigin, xi, yi, xBasisVector, yBasisVector) {
        const xVector = scaleVector(xBasisVector, xi);
        const yVector = scaleVector(yBasisVector, yi);
        const p = vOrigin.clone();
        p.setCoordinates(addVectors(vOrigin.getCoordinates(), xVector, yVector));
        return p;
      }
      function invertTwoByTwoMatrix(M) {
        const A = M[0][0];
        const B = M[0][1];
        const C = M[1][0];
        const D = M[1][1];
        const divisor = A * D - B * C;
        return [
          [
            D / divisor,
            -B / divisor
          ],
          [
            -C / divisor,
            A / divisor
          ]
        ];
      }
      function multiplyTwoByTwoMatrixByTwoVector(M, V) {
        const A = M[0][0];
        const B = M[0][1];
        const C = M[1][0];
        const D = M[1][1];
        const E = V[0];
        const F = V[1];
        return [
          A * E + C * F,
          B * E + D * F
        ];
      }
      function getCoordinateVector(bx, by, Z) {
        const I = invertTwoByTwoMatrix([bx, by]);
        return multiplyTwoByTwoMatrixByTwoVector(I, Z);
      }
      function getIntegerCoordinateVector(bx, by, Z, roundingFunction) {
        const round = roundingFunction || Math.round;
        const cv = getCoordinateVector(bx, by, Z);
        return [round(cv[0]), round(cv[1])];
      }
      function subtractVectors(va, vb) {
        return [va[0] - vb[0], va[1] - vb[1]];
      }
      function addVectors(va, vb, vc) {
        if (vc) {
          return [va[0] + vb[0] + vc[0], va[1] + vb[1] + vc[1]];
        }
        return [va[0] + vb[0], va[1] + vb[1]];
      }
      function scaleVector(v, c) {
        return [v[0] * c, v[1] * c];
      }
      function elementWiseVectorProduct(va, vb) {
        return [va[0] * vb[0], va[1] * vb[1]];
      }
      function getAlignedIntegerCoordinateVector(origin, bx, by, Z, roundingFunction) {
        const zOffset = subtractVectors(Z, origin);
        return getIntegerCoordinateVector(bx, by, zOffset, roundingFunction);
      }
      function getCoordinateVectorsToExtentCorners(origin, bx, by, extent) {
        return [
          getAlignedIntegerCoordinateVector(origin, bx, by, [extent[0], extent[1]], Math.ceil),
          getAlignedIntegerCoordinateVector(origin, bx, by, [extent[2], extent[3]], Math.ceil),
          getAlignedIntegerCoordinateVector(origin, bx, by, [extent[0], extent[3]], Math.ceil),
          getAlignedIntegerCoordinateVector(origin, bx, by, [extent[2], extent[1]], Math.ceil)
        ];
      }
      function calculateGridPoints(viewExtent, vOrigin, vGridExtentCoordinateVectors, xBasisVector, yBasisVector, maxPointsPerSide) {
        const x1 = vGridExtentCoordinateVectors[0][0];
        const y1 = vGridExtentCoordinateVectors[0][1];
        const x2 = vGridExtentCoordinateVectors[1][0];
        const y2 = vGridExtentCoordinateVectors[1][1];
        const x3 = vGridExtentCoordinateVectors[2][0];
        const y3 = vGridExtentCoordinateVectors[2][1];
        const x4 = vGridExtentCoordinateVectors[3][0];
        const y4 = vGridExtentCoordinateVectors[3][1];
        const minX = Math.min(x1, x2, x3, x4);
        const minY = Math.min(y1, y2, y3, y4);
        const maxX = Math.max(x1, x2, x3, x4);
        const maxY = Math.max(y1, y2, y3, y4);
        const deltaX = maxX - minX;
        const deltaY = maxY - minY;
        const incrementX = Math.max(1, Math.floor(deltaX / maxPointsPerSide));
        const incrementY = Math.max(1, Math.floor(deltaY / maxPointsPerSide));
        const gridPointCoords = [];
        for (let xi = minX; xi <= maxX; xi += incrementX) {
          for (let yi = minY; yi <= maxY; yi += incrementY) {
            const gridPoint = getGridPoint(vOrigin, xi, yi, xBasisVector, yBasisVector);
            if (gridPoint.intersectsExtent(viewExtent)) {
              gridPointCoords.push(gridPoint.getCoordinates());
            }
          }
        }
        return gridPointCoords;
      }
      function createAlwaysVisibleVectorSource() {
        const vectorSource = new VectorSource$1({
          useSpatialIndex: false,
          features: [],
          wrapX: false
        });
        vectorSource.getFeaturesInExtent = vectorSource.getFeatures;
        return vectorSource;
      }
      return Grid;
    });
  }
});
export default require_ol_grid_umd();
//# sourceMappingURL=ol-grid.js.map
